diff -Naur linux-rockchip-rk-6.1-rkr6.1_orig/drivers/phy/rockchip/phy-rockchip-inno-usb2.c linux-rockchip-rk-6.1-rkr6.1_modify/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
--- linux-rockchip-rk-6.1-rkr6.1_orig/drivers/phy/rockchip/phy-rockchip-inno-usb2.c	2025-07-03 13:59:45.000000000 +0300
+++ linux-rockchip-rk-6.1-rkr6.1_modify/drivers/phy/rockchip/phy-rockchip-inno-usb2.c	2025-11-10 12:55:04.382546340 +0300
@@ -1047,6 +1047,8 @@
 	bool vbus_det_en;
 	int ret = 0;
 
+	dev_info(rphy->dev, "USB2PHY set_mode called: mode=%d, submode=%d\n", mode, submode);
+
 	if (rport->port_id != USB2PHY_PORT_OTG)
 		return ret;
 
@@ -1069,6 +1071,9 @@
 		 * enable vbus detect on otg mode.
 		 */
 		fallthrough;
+	case PHY_MODE_USB_DEVICE_HS:
+	case PHY_MODE_USB_DEVICE_FS:
+	case PHY_MODE_USB_DEVICE_LS:
 	case PHY_MODE_USB_DEVICE:
 		/* Disable VBUS supply */
 		rockchip_set_vbus_power(rport, false);
@@ -1079,6 +1084,9 @@
 		rport->perip_connected = true;
 		vbus_det_en = true;
 		break;
+	case PHY_MODE_USB_HOST_HS:
+	case PHY_MODE_USB_HOST_FS:
+	case PHY_MODE_USB_HOST_LS:
 	case PHY_MODE_USB_HOST:
 		/* Enable VBUS supply */
 		ret = rockchip_set_vbus_power(rport, true);
@@ -1093,7 +1101,7 @@
 		if (rport->vbus_always_on)
 			extcon_set_state(rphy->edev, EXTCON_USB, false);
 		rport->perip_connected = false;
-		fallthrough;
+		break;
 	case PHY_MODE_INVALID:
 		vbus_det_en = false;
 		break;
@@ -2478,7 +2486,11 @@
 	rphy->chg_state = USB_CHG_STATE_UNDEFINED;
 	rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
 	rphy->edev_self = false;
-	rphy->irq = platform_get_irq(pdev, 0);
+	rphy->irq = platform_get_irq_optional(pdev, 0);
+	if (rphy->irq < 0) {
+		rphy->irq = 0; /* No main IRQ, use port-specific IRQs only */
+		dev_info(rphy->dev, "No main USB2PHY IRQ found, using port-specific IRQs only\n");
+	}
 	platform_set_drvdata(pdev, rphy);
 
 	ret = rockchip_usb2phy_extcon_register(rphy);
@@ -3045,6 +3057,8 @@
 
 static int rv1106_usb2phy_tuning(struct rockchip_usb2phy *rphy)
 {
+	dev_info(rphy->dev, "Applying kernel 6.1 USB2PHY tuning for high-speed detection\n");
+
 	/* Always enable pre-emphasis in SOF & EOP & chirp & non-chirp state */
 	phy_update_bits(rphy->phy_base + 0x30, GENMASK(2, 0), 0x07);
 
@@ -3056,8 +3070,8 @@
 		phy_update_bits(rphy->phy_base + 0x40, GENMASK(5, 3), (0x03 << 3));
 	}
 
-	/* Set RX Squelch trigger point configure to 4'b0000(112.5 mV) */
-	phy_update_bits(rphy->phy_base + 0x64, GENMASK(6, 3), (0x00 << 3));
+	/* Set RX Squelch trigger point configure to 4'b0110(162.5 mV) for better high-speed detection */
+	phy_update_bits(rphy->phy_base + 0x64, GENMASK(6, 3), (0x06 << 3));
 
 	/* Turn off differential receiver by default to save power */
 	phy_clear_bits(rphy->phy_base + 0x100, BIT(6));
@@ -3065,8 +3079,8 @@
 	/* Set 45ohm HS ODT value to 5'b10111 to increase driver strength */
 	phy_update_bits(rphy->phy_base + 0x11c, GENMASK(4, 0), 0x17);
 
-	/* Set Tx HS eye height tuning to 3'b011(462 mV)*/
-	phy_update_bits(rphy->phy_base + 0x124, GENMASK(4, 2), (0x03 << 2));
+	/* Set Tx HS eye height tuning to 3'b111(548 mV) for better signal integrity in kernel 6.1 */
+	phy_update_bits(rphy->phy_base + 0x124, GENMASK(4, 2), (0x07 << 2));
 
 	/* Bypass Squelch detector calibration */
 	phy_update_bits(rphy->phy_base + 0x1a4, GENMASK(7, 4), (0x01 << 4));
diff -Naur linux-rockchip-rk-6.1-rkr6.1_orig/scripts/dtc/include-prefixes/arm/Makefile linux-rockchip-rk-6.1-rkr6.1_modify/scripts/dtc/include-prefixes/arm/Makefile
--- linux-rockchip-rk-6.1-rkr6.1_orig/scripts/dtc/include-prefixes/arm/Makefile	2025-07-03 13:59:45.000000000 +0300
+++ linux-rockchip-rk-6.1-rkr6.1_modify/scripts/dtc/include-prefixes/arm/Makefile	2025-11-07 17:11:17.088713026 +0300
@@ -1122,152 +1122,9 @@
 	r9a06g032-rzn1d400-db.dtb \
 	sh73a0-kzm9g.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += \
-	rv1103g-38x38-ipc-v10.dtb \
-	rv1103g-battery-ipc-v10.dtb \
-	rv1103g-battery-ipc-v11.dtb \
-	rv1103g-evb-mcu-display-v11.dtb \
-	rv1103g-evb-v10.dtb \
-	rv1103g-evb-v11.dtb \
-	rv1103g-evb-v11-sii902x-bt6562hdmi.dtb \
-	rv1103g-evb2-v10.dtb \
-	rv1103g-rmsl311-dloc-sl-v10.dtb \
-	rv1103g-scaner-v10.dtb \
-	rv1106g-38x38-ipc-v10.dtb \
-	rv1106g-38x38-ipc-v10-spi-nand.dtb \
-	rv1106g-evb1-mcu-display-v11.dtb \
-	rv1106g-evb1-mcu-display-v20.dtb \
-	rv1106g-evb1-rgb-display-v11.dtb \
-	rv1106g-evb1-v10.dtb \
-	rv1106g-evb1-v10-dual-cam.dtb \
-	rv1106g-evb1-v10-facial-gate.dtb \
-	rv1106g-evb1-v10-spi-nand.dtb \
-	rv1106g-evb1-v10-spi-nor.dtb \
-	rv1106g-evb1-v11.dtb \
-	rv1106g-evb1-v11-4k.dtb \
-	rv1106g-evb1-v11-cvr.dtb \
-	rv1106g-evb1-v11-cvr-dual-cam.dtb \
-	rv1106g-evb1-v11-cvr-ext-dual-cam.dtb \
-	rv1106g-evb1-v11-dual-cam.dtb \
-	rv1106g-evb1-v11-facial-gate.dtb \
-	rv1106g-evb1-v11-nofastae-spi-nand.dtb \
-	rv1106g-evb1-v11-sii902x-bt11202hdmi.dtb \
-	rv1106g-evb1-v11-sii902x-rgb2hdmi.dtb \
-	rv1106g-evb1-v11-spi-nand-cvr.dtb \
-	rv1106g-evb2-v10.dtb \
-	rv1106g-evb2-v10-dual-camera.dtb \
-	rv1106g-evb2-v11-emmc.dtb \
-	rv1106g-evb2-v11-trailcam-emmc.dtb \
-	rv1106g-evb2-v12-aov-spi-nor.dtb \
-	rv1106g-evb2-v12-dual-camera-avs.dtb \
-	rv1106g-evb2-v12-nofastae-emmc.dtb \
-	rv1106g-evb2-v12-nofastae-spi-nand.dtb \
-	rv1106g-evb2-v12-nofastae-spi-nor.dtb \
-	rv1106g-evb2-v12-spi-nand-tb.dtb \
-	rv1106g-evb2-v12-wakeup.dtb \
-	rv1106g-smart-door-lock-rmsl-v10.dtb \
-	rv1106g-smart-door-lock-rmsl-v12.dtb \
-	rv1106g-uvc-demo-v10.dtb \
-	rv1106g-uvc-demo-v10-spi-nor.dtb \
-	rv1108-elgin-r1.dtb \
-	rv1108-evb.dtb \
-	rv1126-evb-ddr3-v10.dtb \
-	rv1126-evb-ddr3-v12.dtb \
-	rv1126-evb-ddr3-v12-spi-nand.dtb \
-	rv1126-evb-ddr3-v12-spi-nor.dtb \
-	rv1126-evb-ddr3-v13.dtb \
-	rv1126b-evb1-v10.dtb \
-	rv1126b-evb1-v10-bt-sco.dtb \
-	rv1126b-evb1-v10-dual-4k.dtb \
-	rv1126b-evb1-v10-dv.dtb \
-	rv1126b-evb1-v10-fastboot-emmc.dtb \
-	rv1126b-evb1-v10-fastboot-spi-nand.dtb \
-	rv1126b-evb1-v10-fastboot-spi-nor.dtb \
-	rv1126b-evb1-v10-spi-nor.dtb \
-	rv1126b-evb1-v11.dtb \
-	rv1126b-evb1-v11-dual-4k.dtb \
-	rv1126b-evb2-v10.dtb \
-	rv1126b-evb2-v10-mcu-k350c4516t.dtb \
-	rv1126b-evb2-v10-rgb-Q7050ITH2641AA1T.dtb \
-	rv1126b-evb2-v10-sii9022-bt1120-to-hdmi.dtb \
-	rv1126b-evb2-v10-tb-400w.dtb \
-	rv1126b-evb3-v10.dtb \
-	rv1126b-evb4-v10.dtb \
-	rv1126b-iotest-v10.dtb \
-	rv1126bp-evb-v14.dtb \
-	rv1126bp-evb-v14-dual-cam.dtb \
-	rk3036-evb.dtb \
-	rk3036-evb1-ddr3-v10.dtb \
-	rk3036-kylin.dtb \
-	rk3066a-bqcurie2.dtb \
-	rk3066a-marsboard.dtb \
-	rk3066a-mk808.dtb \
-	rk3066a-rayeager.dtb \
-	rk3126c-evb-ddr3-v10-linux.dtb \
-	rk3126c-evb-ddr3-v10-linux-slc.dtb \
-	rk3128-evb-ddr3-v10-linux.dtb \
-	rk3128-evb-ddr3-v10-linux-spi-nand.dtb \
-	rk3188-bqedison2qc.dtb \
-	rk3188-px3-evb.dtb \
-	rk3188-radxarock.dtb \
-	rk3228-evb.dtb \
-	rk3229-evb.dtb \
-	rk3229-xms6.dtb \
-	rk3288-evb-act8846.dtb \
-	rk3288-evb-rk808.dtb \
-	rk3288-firefly-beta.dtb \
-	rk3288-firefly.dtb \
-	rk3288-firefly-reload.dtb \
-	rk3288-miqi.dtb \
-	rk3288-phycore-rdk.dtb \
-	rk3288-popmetal.dtb \
-	rk3288-r89.dtb \
-	rk3288-rock2-square.dtb \
-	rk3288-rock-pi-n8.dtb \
-	rk3288-tinker.dtb \
-	rk3288-tinker-s.dtb \
-	rk3288-veyron-brain.dtb \
-	rk3288-veyron-fievel.dtb \
-	rk3288-veyron-jaq.dtb \
-	rk3288-veyron-jerry.dtb \
-	rk3288-veyron-mickey.dtb \
-	rk3288-veyron-mighty.dtb \
-	rk3288-veyron-minnie.dtb \
-	rk3288-veyron-pinky.dtb \
-	rk3288-veyron-speedy.dtb \
-	rk3288-veyron-tiger.dtb \
-	rk3288-vyasa.dtb \
-	rk3308-evb-audio-v10-amp-display-rgb-aarch32.dtb \
-	rk3308-evb-audio-v10-display-rgb-aarch32.dtb \
-	rk3308-evb-audio-v11-display-rgb-aarch32.dtb \
-	rk3308bs-evb-amic-v11-aarch32.dtb \
-	rk3308bs-evb-dmic-pdm-v11-aarch32.dtb \
-	rk3308bs-evb-mipi-display-v11-aarch32.dtb \
-	rk3308hs-voice-module-board-v10-aarch32.dtb \
-	rk3502g-evb1-v10.dtb \
-	rk3503g-evb1-v10.dtb \
-	rk3506b-evb1-v10.dtb \
-	rk3506b-test2-v10.dtb \
-	rk3506g-demo-display-control.dtb \
-	rk3506g-evb1-v10.dtb \
-	rk3506g-evb1-v10-amp.dtb \
-	rk3506g-evb1-v10-dsmc-lb-slave.dtb \
-	rk3506g-evb1-v10-dsmc-master.dtb \
-	rk3506g-evb1-v10-flexbus-adc-dac.dtb \
-	rk3506g-evb1-v10-mcu-k350c4516t.dtb \
-	rk3506g-evb1-v10-rgb-Q7050ITH2641AA1T.dtb \
-	rk3506g-evb1-v10-sii9022-bt1120-to-hdmi.dtb \
-	rk3506g-evb1-v10-sii9022-rgb2hdmi.dtb \
-	rk3506g-evb2-v10.dtb \
-	rk3506g-iotest-v10.dtb \
-	rk3506g-iotest-v10-pdm.dtb \
-	rk3506g-test1-v10-audio.dtb \
-	rk3518-evb1-ddr4-v10.dtb \
-	rk3528-demo4-ddr4-v10.dtb \
-	rk3528-evb1-ddr4-v10.dtb \
-	rk3528-evb2-ddr3-v10.dtb \
-	rk3528-evb3-lp4x-v10.dtb \
-	rk3528-evb4-ddr4-v10.dtb \
-	rk3562-evb2-ddr4-v10.dtb
+	rv1106_ext.dtb \
+	rv1106_512_ext.dtb \
+	rv1106_pll.dtb
 dtb-$(CONFIG_ARCH_S3C24XX) += \
 	s3c2416-smdk2416.dtb
 dtb-$(CONFIG_ARCH_S3C64XX) += \
diff -Naur linux-rockchip-rk-6.1-rkr6.1_orig/sound/soc/codecs/dummy-codec.c linux-rockchip-rk-6.1-rkr6.1_modify/sound/soc/codecs/dummy-codec.c
--- linux-rockchip-rk-6.1-rkr6.1_orig/sound/soc/codecs/dummy-codec.c	2025-07-03 13:59:45.000000000 +0300
+++ linux-rockchip-rk-6.1-rkr6.1_modify/sound/soc/codecs/dummy-codec.c	2025-11-07 12:03:40.403261526 +0300
@@ -48,25 +48,31 @@
 	.name = "dummy_codec",
 	.playback = {
 		.stream_name = "Dummy Playback",
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 384,
-		.rates = SNDRV_PCM_RATE_CONTINUOUS,
-		.formats = (SNDRV_PCM_FMTBIT_S8 |
-			    SNDRV_PCM_FMTBIT_S16_LE |
+		.rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 8000,
+		.rate_max = 22579200,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
 			    SNDRV_PCM_FMTBIT_S20_3LE |
 			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
+			    SNDRV_PCM_FMTBIT_S32_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U16_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U32_LE),
 	},
 	.capture = {
 		.stream_name = "Dummy Capture",
-		.channels_min = 1,
+		.channels_min = 2,
 		.channels_max = 384,
-		.rates = SNDRV_PCM_RATE_CONTINUOUS,
-		.formats = (SNDRV_PCM_FMTBIT_S8 |
-			    SNDRV_PCM_FMTBIT_S16_LE |
+		.rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+		.rate_min = 8000,
+		.rate_max = 22579200,
+		.formats = (SNDRV_PCM_FMTBIT_S16_LE |
 			    SNDRV_PCM_FMTBIT_S20_3LE |
 			    SNDRV_PCM_FMTBIT_S24_LE |
-			    SNDRV_PCM_FMTBIT_S32_LE),
+			    SNDRV_PCM_FMTBIT_S32_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U16_LE |
+			    SNDRV_PCM_FMTBIT_DSD_U32_LE),
 	},
 	.ops = &dummy_codec_dai_ops,
 };
diff -Naur linux-rockchip-rk-6.1-rkr6.1_orig/sound/soc/rockchip/rockchip_i2s_tdm.c linux-rockchip-rk-6.1-rkr6.1_modify/sound/soc/rockchip/rockchip_i2s_tdm.c
--- linux-rockchip-rk-6.1-rkr6.1_orig/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-07-03 13:59:45.000000000 +0300
+++ linux-rockchip-rk-6.1-rkr6.1_modify/sound/soc/rockchip/rockchip_i2s_tdm.c	2025-11-10 16:09:54.515037253 +0300
@@ -1,31 +1,46 @@
-// SPDX-License-Identifier: GPL-2.0-only
-// ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
-
-// Copyright (c) 2018 Rockchip Electronics Co., Ltd.
-// Author: Sugar Zhang <sugar.zhang@rock-chips.com>
-// Author: Nicolas Frattaroli <frattaroli.nicolas@gmail.com>
-
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/delay.h>
-#include <linux/mfd/syscon.h>
+/* sound/soc/rockchip/rockchip_i2s_tdm.c
+ *
+ * ALSA SoC Audio Layer - Rockchip I2S/TDM Controller driver
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ * Author: Sugar Zhang <sugar.zhang@rock-chips.com>
+ */
 #include <linux/module.h>
-#include <linux/of_address.h>
-#include <linux/of_device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/delay.h>
 #include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/gpio/consumer.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/clk/rockchip.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
-#include <sound/dmaengine_pcm.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/random.h>
+#include <linux/math64.h>
+#include <linux/version.h>
 #include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/soc.h>
+
+/* Conditional NEON compilation */
+#ifdef CONFIG_KERNEL_MODE_NEON
+#include <linux/kernel.h>
+#include <asm/neon.h>
+#include <asm/simd.h>
+/* Disable NEON intrinsics for soft-float ABI */
+#if defined(__ARM_NEON__) && !defined(__SOFTFP__)
+#include <arm_neon.h>
+#define HAVE_NEON_SUPPORT
+#endif
+#endif
 
 #include "rockchip_i2s_tdm.h"
-#include "rockchip_dlp_pcm.h"
-#include "rockchip_utils.h"
-#include "rockchip_trcm.h"
+#include "rockchip_dlp.h"
 
 #define DRV_NAME "rockchip-i2s-tdm"
 
@@ -33,518 +48,594 @@
 #define HAVE_SYNC_RESET
 #endif
 
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-/*
- * Example: RK3588
- *
- * Use I2S2_2CH as Clk-Gen to serve TDM_MULTI_LANES
- *
- * I2S2_2CH ----> BCLK,I2S_LRCK --------> I2S0_8CH_TX (Slave TRCM-TXONLY)
- *     |
- *     |--------> BCLK,TDM_SYNC --------> TDM Device (Slave)
- *
- * Note:
- *
- * I2S2_2CH_MCLK: BCLK
- * I2S2_2CH_SCLK: I2S_LRCK (GPIO2_B7)
- * I2S2_2CH_LRCK: TDM_SYNC (GPIO2_C0)
- *
- */
-
-#define XFER_EN					0x3
-#define XFER_DIS				0x0
-#define CKR_V(m, r, t)				((m - 1) << 16 | (r - 1) << 8 | (t - 1) << 0)
-#define I2S_XCR_IBM_V(v)			((v) & I2S_TXCR_IBM_MASK)
-#define I2S_XCR_IBM_NORMAL			I2S_TXCR_IBM_NORMAL
-#define I2S_XCR_IBM_LSJM			I2S_TXCR_IBM_LSJM
-#endif
-
-#define CLK_MAX_COUNT				1000
-#define NSAMPLES				4
 #define DEFAULT_MCLK_FS				256
 #define DEFAULT_FS				48000
 #define CH_GRP_MAX				4  /* The max channel 8 / 2 */
 #define MULTIPLEX_CH_MAX			10
 #define CLK_PPM_MIN				(-1000)
 #define CLK_PPM_MAX				(1000)
-#define CLK_SHIFT_RATE_HZ_MAX			5
-#define MAXBURST				16
-#define MAXBURST_PER_FIFO			8
-#define DEPTH_PER_FIFO				32
-#define WAIT_TIME_MS_MAX			10000
-
-#define TRCM_TXRX				0
-#define TRCM_TX					1
-#define TRCM_RX					2
+#define MAXBURST_PER_FIFO			64  /* Match kernel 5.10 for proper DMA alignment */
+
+/* Auto-mute timing defaults */
+#define DEFAULT_POSTMUTE_DELAY_MS		450
 
 #define QUIRK_ALWAYS_ON				BIT(0)
 #define QUIRK_HDMI_PATH				BIT(1)
+#define QUIRK_MCLK_ALWAYS_ON			BIT(2)
+
 
 struct txrx_config {
-	u32 addr;
-	u32 reg;
-	u32 txonly;
-	u32 rxonly;
+    u32 addr;
+    u32 reg;
+    u32 txonly;
+    u32 rxonly;
 };
 
-struct rk_i2s_tdm_dev;
-
 struct rk_i2s_soc_data {
-	u32 softrst_offset;
-	u32 grf_reg_offset;
-	u32 grf_shift;
-	int config_count;
-	const struct txrx_config *configs;
-	int (*init)(struct device *dev, u32 addr);
-	void (*src_clk_ctrl)(struct rk_i2s_tdm_dev *i2s_tdm, bool en);
+    u32 softrst_offset;
+    u32 grf_reg_offset;
+    u32 grf_shift;
+    int config_count;
+    const struct txrx_config *configs;
+    int (*init)(struct device *dev, u32 addr);
 };
 
 struct rk_i2s_tdm_dev {
-	struct device *dev;
-	struct clk *hclk;
-	struct clk *mclk_tx;
-	struct clk *mclk_rx;
-	/* The mclk_tx_src is parent of mclk_tx */
-	struct clk *mclk_tx_src;
-	/* The mclk_rx_src is parent of mclk_rx */
-	struct clk *mclk_rx_src;
-	/*
-	 * The mclk_root0 and mclk_root1 are root parent and supplies for
-	 * the different FS.
-	 *
-	 * e.g:
-	 * mclk_root0 is VPLL0, used for FS=48000Hz
-	 * mclk_root1 is VPLL1, used for FS=44100Hz
-	 */
-	struct clk *mclk_root0;
-	struct clk *mclk_root1;
-	struct regmap *regmap;
-	struct regmap *grf;
-	struct snd_dmaengine_dai_dma_data capture_dma_data;
-	struct snd_dmaengine_dai_dma_data playback_dma_data;
-	struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
-	unsigned int wait_time[SNDRV_PCM_STREAM_LAST + 1];
-	struct snd_soc_component *pcm_comp;
-	struct reset_control *tx_reset;
-	struct reset_control *rx_reset;
-	struct pinctrl *pinctrl;
-	struct pinctrl_state *clk_state;
-	const struct rk_i2s_soc_data *soc_data;
+    struct device *dev;
+    struct clk *hclk;
+    struct clk *mclk_tx;
+    struct clk *mclk_rx;
+    /* The mclk_tx_src is parent of mclk_tx */
+    struct clk *mclk_tx_src;
+    /* The mclk_rx_src is parent of mclk_rx */
+    struct clk *mclk_rx_src;
+    /*
+     * The mclk_root0 and mclk_root1 are root parent and supplies for
+     * the different FS.
+     */
+    struct clk *mclk_root0;
+    struct clk *mclk_root1;
+    struct clk *mclk_out;  /* MCLKOUT pin clock for external DAC */
+    bool mclk_external;
+    bool mclk_ext_mux;
+    struct clk *mclk_ext;
+    struct clk *clk_44;
+    struct clk *clk_48;
+    struct regmap *regmap;
+    struct regmap *grf;
+    struct snd_dmaengine_dai_dma_data capture_dma_data;
+    struct snd_dmaengine_dai_dma_data playback_dma_data;
+    struct snd_pcm_substream *substreams[SNDRV_PCM_STREAM_LAST + 1];
+    struct reset_control *tx_reset;
+    struct reset_control *rx_reset;
+    const struct rk_i2s_soc_data *soc_data;
 #ifdef HAVE_SYNC_RESET
-	int id;
-	void __iomem *cru_base;
-#endif
-	bool is_master_mode;
-	bool io_multiplex;
-	bool mclk_calibrate;
-	bool tdm_mode;
-	bool tdm_fsync_half_frame;
-	bool is_dma_active[SNDRV_PCM_STREAM_LAST + 1];
-	bool no_pcm;
-	unsigned int mclk_rx_freq;
-	unsigned int mclk_tx_freq;
-	unsigned int mclk_root0_freq;
-	unsigned int mclk_root1_freq;
-	unsigned int mclk_root0_initial_freq;
-	unsigned int mclk_root1_initial_freq;
-	unsigned int frame_width;
-	unsigned int clk_trcm;
-	unsigned int i2s_sdis[CH_GRP_MAX];
-	unsigned int i2s_sdos[CH_GRP_MAX];
-	unsigned int quirks;
-	unsigned int lrck_ratio;
-	unsigned int tdm_slots;
-	unsigned int resume_deferred_ms;
-	int clk_ppm;
-	int refcount;
-	spinlock_t lock; /* xfer lock */
-	bool has_playback;
-	bool has_capture;
-	struct snd_soc_dai_driver *dai;
-	struct gpio_desc *i2s_lrck_gpio;
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	struct snd_soc_dai *clk_src_dai;
-	struct gpio_desc *tdm_fsync_gpio;
-	struct gpio_desc *fsxn_tx_gpio;
-	struct gpio_desc *fsxn_rx_gpio;
-	unsigned int tx_lanes;
-	unsigned int rx_lanes;
-	void __iomem *clk_src_base;
-	bool is_tdm_multi_lanes;
-#endif
-};
+    void __iomem *cru_base;
+    int tx_reset_id;
+    int rx_reset_id;
+#endif
+    bool is_master_mode;
+    bool io_multiplex;
+    bool mclk_calibrate;
+    bool tdm_mode;
+    bool tdm_fsync_half_frame;
+    unsigned int mclk_rx_freq;
+    unsigned int mclk_tx_freq;
+    unsigned int mclk_root0_freq;
+    unsigned int mclk_root1_freq;
+    unsigned int mclk_root0_initial_freq;
+    unsigned int mclk_root1_initial_freq;
+    unsigned int bclk_fs;
+    unsigned int clk_trcm;
+    unsigned int i2s_sdis[CH_GRP_MAX];
+    unsigned int i2s_sdos[CH_GRP_MAX];
+    unsigned int quirks;
+    int clk_ppm;
+    atomic_t refcount;
+    spinlock_t lock; /* xfer lock */
+    int volume;
+    bool mute;
+    struct gpio_desc *mute_gpio;
+    struct gpio_desc *mute_inv_gpio;  /* Inverted mute signal (GPIO2_A5, pin 69) */
+    struct gpio_desc *freq_domain_gpio;  /* Frequency domain indicator GPIO (GPIO1_D1) 44.1/48 kHz */
+    bool freq_domain_invert;        // Invert frequency domain GPIO polarity
+    
+    /* MCLK multiplier for switching 512/1024 */
+    int mclk_multiplier;            // MCLK multiplier: 512 or 1024
+    
+    /* Automatic mute during switching */
+    bool auto_mute_active;          // Active state of automatic mute
+    bool user_mute_priority;        // User priority over automation
+    bool format_change_mute;        // Mute during PCM/DSD format change (higher priority)
+    struct delayed_work mute_post_work;   // Timer to disable mute after delay
+    struct mutex mute_lock;         // Mutex for protecting mute operations
+    
+    
+    /* Add pause state */
+    bool playback_paused;
+    bool capture_paused;
+    
+    /* Debounce for auto-mute */
+    unsigned long last_auto_mute_time;
+    
+    /* Configurable auto-mute times via sysfs */
+    unsigned int postmute_delay_ms;     // Mute hold time after start (default 450ms)
+    
+    /* GPIO for DSD-on signal */
+    struct gpio_desc *dsd_on_gpio;
+    bool dsd_mode_active;
+    
+    /* DSD sample swap to eliminate purple noise */
+    bool dsd_sample_swap;
+    
+    /* Channel swap controls */
+    bool pcm_channel_swap;     /* PCM: LRCK inversion */
+    bool dsd_physical_swap;    /* DSD: swap pins A6/A3 */
+    
+    /* ALSA control for sysfs and alsamixer synchronization */
+    struct snd_kcontrol *mute_kcontrol;
+    struct snd_soc_dai *dai; /* For ALSA card access */
+    
+    /* Saved format for forced changes application */
+    unsigned int format;
+};
+
+/* Forward declarations for auto-mute functions */
+static void rockchip_i2s_tdm_apply_mute(struct rk_i2s_tdm_dev *i2s_tdm, bool enable);
+static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm, int num);
+static void rockchip_i2s_tdm_handle_dsd_switch(struct rk_i2s_tdm_dev *i2s_tdm, bool enable_dsd);
+
+
+
+/* DSD physical channel swap function (I2S routing) */
+static void rockchip_i2s_tdm_apply_dsd_physical_swap(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    /* Change I2S TX routing for DSD physical swap
+     * Standard configuration: i2s_sdos[0]=2, i2s_sdos[1]=3, i2s_sdos[2]=0, i2s_sdos[3]=1
+     * Swap configuration: exchange i2s_sdos[1] and i2s_sdos[3] (channels A6/A3)
+     * IMPORTANT: swap applies only in DSD mode!
+     */
+    
+    
+    if (i2s_tdm->dsd_physical_swap && i2s_tdm->dsd_mode_active) {
+        /* Check if swap needs to be applied - only if routing is standard [2,3,0,1] */
+        if (i2s_tdm->i2s_sdos[2] == 0 && i2s_tdm->i2s_sdos[3] == 1) {
+            /* Swap: exchange channels 2 and 3 (A6/A3) */
+            unsigned int temp = i2s_tdm->i2s_sdos[2];
+            i2s_tdm->i2s_sdos[2] = i2s_tdm->i2s_sdos[3];
+            i2s_tdm->i2s_sdos[3] = temp;
+            
+            
+            /* Apply new routing */
+            rockchip_i2s_tdm_tx_path_config(i2s_tdm, 4);
+        }
+    } else {
+        /* Check if standard routing needs to be restored - only if current is swap [2,3,1,0] */
+        if (i2s_tdm->i2s_sdos[2] == 1 && i2s_tdm->i2s_sdos[3] == 0) {
+            /* Restore standard configuration: 2,3,0,1 */
+            i2s_tdm->i2s_sdos[0] = 2;
+            i2s_tdm->i2s_sdos[1] = 3;
+            i2s_tdm->i2s_sdos[2] = 0;
+            i2s_tdm->i2s_sdos[3] = 1;
+            
+            
+            /* Apply standard routing */
+            rockchip_i2s_tdm_tx_path_config(i2s_tdm, 4);
+        }
+    }
+}
+
+/* DSD format detection */
+static inline int is_dsd(snd_pcm_format_t format)
+{
+    switch (format) {
+        case SNDRV_PCM_FORMAT_DSD_U8:
+        case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        case SNDRV_PCM_FORMAT_DSD_U16_BE:
+        case SNDRV_PCM_FORMAT_DSD_U32_LE:
+        case SNDRV_PCM_FORMAT_DSD_U32_BE:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+/* Common DSD switch handling function */
+static void rockchip_i2s_tdm_handle_dsd_switch(struct rk_i2s_tdm_dev *i2s_tdm, bool enable_dsd)
+{
+    if (!i2s_tdm->dsd_on_gpio)
+        return;
+
+    if (enable_dsd == i2s_tdm->dsd_mode_active)
+        return;  /* Already in desired state */
+
+    /* Enable mute before format switch to eliminate clicks */
+    if (i2s_tdm->mute_gpio) {
+        /* Cancel any pending post-mute work from trigger */
+        cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
+
+        i2s_tdm->format_change_mute = true;
+        gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        if (i2s_tdm->mute_inv_gpio)
+            gpiod_set_value(i2s_tdm->mute_inv_gpio, 0);
+        msleep(50);
+    }
+
+    if (enable_dsd) {
+        i2s_tdm->dsd_mode_active = true;
+        gpiod_set_value(i2s_tdm->dsd_on_gpio, 1);
+        dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO activated (DSD mode ON)\n");
+    } else {
+        i2s_tdm->dsd_mode_active = false;
+        gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+        dev_info(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO deactivated (PCM mode)\n");
+    }
+
+    /* Apply routing for the new mode */
+    rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+
+    /* Wait for DAC to settle, then let normal trigger unmute handle it */
+    if (i2s_tdm->mute_gpio) {
+        msleep(500);
+        /* Clear flag and restore auto_mute for next trigger */
+        i2s_tdm->format_change_mute = false;
+        i2s_tdm->auto_mute_active = true;
+        /* DO NOT unmute here - let trigger's mute_post_work handle it */
+    }
+}
+
+/* Calculate proper BCLK frequency for DSD formats */
+static unsigned int calculate_dsd_bclk(snd_pcm_format_t format, unsigned int sample_rate)
+{
+    /* CORRECT BCLK frequencies for DSD (determine by sample_rate):
+     * DSD64: BCLK = 2.8224 MHz 
+     * DSD128: BCLK = 5.6448 MHz  
+     * DSD256: BCLK = 11.2896 MHz
+     * DSD512: BCLK = 22.5792 MHz
+     */
+    
+    /* Determine DSD type by sample_rate */
+    if (sample_rate <= 88200) {
+        return 2822400;  /* DSD64: 2.8224 MHz - CORRECT! */
+    } else if (sample_rate <= 176400) {
+        return 5644800;  /* DSD128: 5.6448 MHz */
+    } else if (sample_rate <= 352800) {
+        return 11289600; /* DSD256: 11.2896 MHz */
+    } else {
+        return 22579200; /* DSD512: 22.5792 MHz */
+    }
+}
+
+static void rockchip_i2s_tdm_mute_post_work(struct work_struct *work);
 
 static struct i2s_of_quirks {
-	char *quirk;
-	int id;
+    char *quirk;
+    int id;
 } of_quirks[] = {
-	{
-		.quirk = "rockchip,always-on",
-		.id = QUIRK_ALWAYS_ON,
-	},
-	{
-		.quirk = "rockchip,hdmi-path",
-		.id = QUIRK_HDMI_PATH,
-	},
+    {
+    .quirk = "rockchip,always-on",
+    .id = QUIRK_ALWAYS_ON,
+    },
+    {
+    .quirk = "rockchip,hdmi-path",
+    .id = QUIRK_HDMI_PATH,
+    },
+    {
+    .quirk = "rockchip,mclk-always-on",
+    .id = QUIRK_MCLK_ALWAYS_ON,
+    },
 };
 
-static int rockchip_trcm_dma_guard_ctrl(struct rk_i2s_tdm_dev *i2s_tdm,
-					int stream, bool en)
-{
-	if (i2s_tdm->no_pcm)
-		return 0;
-
-	if (!i2s_tdm->pcm_comp) {
-		dev_err(i2s_tdm->dev, "Uninitialized component for TRCM\n");
-		return -EINVAL;
-	}
-
-	return dmaengine_trcm_dma_guard_ctrl(i2s_tdm->pcm_comp, stream, en);
-}
-
-static bool rockchip_i2s_tdm_stream_valid(struct snd_pcm_substream *substream,
-					  struct snd_soc_dai *dai)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-
-	if (!substream)
-		return false;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
-	    i2s_tdm->has_playback)
-		return true;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
-	    i2s_tdm->has_capture)
-		return true;
-
-	return false;
-}
 
 static int to_ch_num(unsigned int val)
 {
-	switch (val) {
-	case I2S_CHN_4:
-		return 4;
-	case I2S_CHN_6:
-		return 6;
-	case I2S_CHN_8:
-		return 8;
-	default:
-		return 2;
-	}
-}
-
-static void i2s_tdm_disable_unprepare_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
-	if (i2s_tdm->mclk_calibrate) {
-		clk_disable_unprepare(i2s_tdm->mclk_tx_src);
-		clk_disable_unprepare(i2s_tdm->mclk_rx_src);
-		clk_disable_unprepare(i2s_tdm->mclk_root0);
-		clk_disable_unprepare(i2s_tdm->mclk_root1);
-	}
-}
-
-/**
- * i2s_tdm_prepare_enable_mclk - prepare to enable all mclks, disable them on
- *				 failure.
- * @i2s_tdm: rk_i2s_tdm_dev struct
- *
- * This function attempts to enable all mclk clocks, but cleans up after
- * itself on failure. Guarantees to balance its calls.
- *
- * Returns success (0) or negative errno.
- */
-static int i2s_tdm_prepare_enable_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	int ret = 0;
+    int chs;
 
-	ret = clk_prepare_enable(i2s_tdm->mclk_tx);
-	if (ret)
-		goto err_mclk_tx;
-	ret = clk_prepare_enable(i2s_tdm->mclk_rx);
-	if (ret)
-		goto err_mclk_rx;
-
-	if (i2s_tdm->mclk_calibrate) {
-		ret = clk_prepare_enable(i2s_tdm->mclk_tx_src);
-		if (ret)
-			goto err_mclk_tx_src;
-		ret = clk_prepare_enable(i2s_tdm->mclk_rx_src);
-		if (ret)
-			goto err_mclk_rx_src;
-		ret = clk_prepare_enable(i2s_tdm->mclk_root0);
-		if (ret)
-			goto err_mclk_root0;
-		ret = clk_prepare_enable(i2s_tdm->mclk_root1);
-		if (ret)
-			goto err_mclk_root1;
-	}
-
-	return 0;
-
-err_mclk_root1:
-	clk_disable_unprepare(i2s_tdm->mclk_root0);
-err_mclk_root0:
-	clk_disable_unprepare(i2s_tdm->mclk_rx_src);
-err_mclk_rx_src:
-	clk_disable_unprepare(i2s_tdm->mclk_tx_src);
-err_mclk_tx_src:
-	clk_disable_unprepare(i2s_tdm->mclk_rx);
+    switch (val) {
+    case I2S_CHN_4:
+    chs = 4;
+    break;
+    case I2S_CHN_6:
+    chs = 6;
+    break;
+    case I2S_CHN_8:
+    chs = 8;
+    break;
+    default:
+    chs = 2;
+    break;
+    }
+
+    return chs;
+}
+
+static int i2s_tdm_runtime_suspend(struct device *dev)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+
+    regcache_cache_only(i2s_tdm->regmap, true);
+    
+    /* Do not turn off MCLK if continuous MCLK quirk is enabled */
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON)) {
+        clk_disable_unprepare(i2s_tdm->mclk_tx);
+        clk_disable_unprepare(i2s_tdm->mclk_rx);
+    } else {
+        dev_dbg(i2s_tdm->dev, "MCLK kept running during suspend (quirk enabled)\n");
+    }
+
+    return 0;
+}
+
+static int i2s_tdm_runtime_resume(struct device *dev)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
+
+    /* Enable MCLK only if it was turned off (quirk not active) */
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON)) {
+        dev_info(i2s_tdm->dev, "Runtime resume: enabling mclk_tx and mclk_rx\n");
+        ret = clk_prepare_enable(i2s_tdm->mclk_tx);
+        if (ret) {
+            dev_err(i2s_tdm->dev, "Failed to enable mclk_tx: %d\n", ret);
+            goto err_mclk_tx;
+        }
+
+        ret = clk_prepare_enable(i2s_tdm->mclk_rx);
+        if (ret) {
+            dev_err(i2s_tdm->dev, "Failed to enable mclk_rx: %d\n", ret);
+            goto err_mclk_rx;
+        }
+        dev_info(i2s_tdm->dev, "Runtime resume: mclk_tx and mclk_rx enabled successfully\n");
+    } else {
+        dev_info(i2s_tdm->dev, "MCLK already running (quirk enabled)\n");
+    }
+
+    regcache_cache_only(i2s_tdm->regmap, false);
+    regcache_mark_dirty(i2s_tdm->regmap);
+
+    ret = regcache_sync(i2s_tdm->regmap);
+    if (ret)
+        goto err_regmap;
+
+    return 0;
+
+err_regmap:
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON))
+        clk_disable_unprepare(i2s_tdm->mclk_rx);
 err_mclk_rx:
-	clk_disable_unprepare(i2s_tdm->mclk_tx);
+    if (!(i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON))
+        clk_disable_unprepare(i2s_tdm->mclk_tx);
 err_mclk_tx:
-	return ret;
+    return ret;
 }
 
 static inline struct rk_i2s_tdm_dev *to_info(struct snd_soc_dai *dai)
 {
-	return snd_soc_dai_get_drvdata(dai);
+    return snd_soc_dai_get_drvdata(dai);
 }
 
 static inline bool is_stream_active(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	unsigned int val;
-
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		return (val & I2S_XFER_TXS_START);
-	else
-		return (val & I2S_XFER_RXS_START);
-}
-
-static inline bool is_dma_active(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
-{
-	unsigned int val;
+    unsigned int val;
 
-	regmap_read(i2s_tdm->regmap, I2S_DMACR, &val);
+    regmap_read(i2s_tdm->regmap, I2S_XFER, &val);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		return (val & I2S_DMACR_TDE_MASK);
-	else
-		return (val & I2S_DMACR_RDE_MASK);
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return (val & I2S_XFER_TXS_START);
+    else
+    return (val & I2S_XFER_RXS_START);
 }
 
 #ifdef HAVE_SYNC_RESET
-static void rockchip_i2s_tdm_src_clk_ctrl(struct rk_i2s_tdm_dev *i2s_tdm, bool en,
-					  unsigned int gate_reg, unsigned int gate_val,
-					  unsigned int sel_reg)
-{
-	int val = readl(i2s_tdm->cru_base + sel_reg);
-
-	if (!gate_reg || !sel_reg)
-		return;
-
-	if (IS_I2S_CLK_SRC_MCLKIN(val) && en)
-		writel(I2S_CLK_SRC_MCLKIN, i2s_tdm->cru_base + sel_reg);
-
-	writel(gate_val, i2s_tdm->cru_base + gate_reg);
-
-	if (IS_I2S_CLK_SRC_MCLKIN(val) && !en)
-		writel(I2S_CLK_SRC_PLL, i2s_tdm->cru_base + sel_reg);
-}
-
-static void rockchip_i2s_tdm_px30_src_clk_ctrl(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
-{
-	unsigned int gate_reg = 0, gate_val = 0, sel_reg = 0;
-
-	switch (i2s_tdm->clk_trcm) {
-	case TRCM_TX:
-		sel_reg  = PX30_CLKSEL_CON28_I2S0_TX;
-		gate_reg = PX30_CLKGATE_CON9;
-		gate_val = en ? PX30_CLKGATE_CON9_I2S0_TX_PLL_EN :
-				PX30_CLKGATE_CON9_I2S0_TX_PLL_DIS;
-		break;
-	case TRCM_RX:
-		sel_reg  = PX30_CLKSEL_CON58_I2S0_RX;
-		gate_reg = PX30_CLKGATE_CON17;
-		gate_val = en ? PX30_CLKGATE_CON17_I2S0_RX_PLL_EN :
-				PX30_CLKGATE_CON17_I2S0_RX_PLL_DIS;
-		break;
-	}
-
-	rockchip_i2s_tdm_src_clk_ctrl(i2s_tdm, en, gate_reg, gate_val, sel_reg);
-}
-
-static void rockchip_i2s_tdm_rk1808_src_clk_ctrl(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
-{
-	unsigned int gate_reg = 0, gate_val = 0, sel_reg = 0;
-
-	switch (i2s_tdm->clk_trcm) {
-	case TRCM_TX:
-		sel_reg  = RK1808_CLKSEL_CON32_I2S0_TX;
-		gate_reg = RK1808_CLKGATE_CON17;
-		gate_val = en ? RK1808_CLKGATE_CON17_I2S0_TX_PLL_EN :
-				RK1808_CLKGATE_CON17_I2S0_TX_PLL_DIS;
-		break;
-	case TRCM_RX:
-		sel_reg  = RK1808_CLKSEL_CON34_I2S0_RX;
-		gate_reg = RK1808_CLKGATE_CON18;
-		gate_val = en ? RK1808_CLKGATE_CON18_I2S0_RX_PLL_EN :
-				RK1808_CLKGATE_CON18_I2S0_RX_PLL_DIS;
-		break;
-	}
-
-	rockchip_i2s_tdm_src_clk_ctrl(i2s_tdm, en, gate_reg, gate_val, sel_reg);
-}
-
-static void rockchip_i2s_tdm_rk3308_src_clk_ctrl(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
-{
-	unsigned int gate_reg = 0, gate_val = 0, sel_reg = 0;
-
-	/* I2S_8CH_2 used for internal and TRCM-none mode default */
-	switch (i2s_tdm->id) {
-	case 0:
-		switch (i2s_tdm->clk_trcm) {
-		case TRCM_TX:
-			sel_reg  = RK3308_CLKSEL_CON52_I2S0_TX;
-			gate_reg = RK3308_CLKGATE_CON10;
-			gate_val = en ? RK3308_CLKGATE_CON10_I2S0_TX_PLL_EN :
-					RK3308_CLKGATE_CON10_I2S0_TX_PLL_DIS;
-			break;
-		case TRCM_RX:
-			sel_reg  = RK3308_CLKSEL_CON54_I2S0_RX;
-			gate_reg = RK3308_CLKGATE_CON11;
-			gate_val = en ? RK3308_CLKGATE_CON11_I2S0_RX_PLL_EN :
-					RK3308_CLKGATE_CON11_I2S0_RX_PLL_DIS;
-			break;
-		}
-		break;
-	case 1:
-		switch (i2s_tdm->clk_trcm) {
-		case TRCM_TX:
-			sel_reg  = RK3308_CLKSEL_CON56_I2S1_TX;
-			gate_reg = RK3308_CLKGATE_CON11;
-			gate_val = en ? RK3308_CLKGATE_CON11_I2S1_TX_PLL_EN :
-					RK3308_CLKGATE_CON11_I2S1_TX_PLL_DIS;
-			break;
-		case TRCM_RX:
-			sel_reg  = RK3308_CLKSEL_CON58_I2S1_RX;
-			gate_reg = RK3308_CLKGATE_CON11;
-			gate_val = en ? RK3308_CLKGATE_CON11_I2S1_RX_PLL_EN :
-					RK3308_CLKGATE_CON11_I2S1_RX_PLL_DIS;
-			break;
-		}
-		break;
-	}
-
-	rockchip_i2s_tdm_src_clk_ctrl(i2s_tdm, en, gate_reg, gate_val, sel_reg);
+#if defined(CONFIG_ARM) && !defined(writeq)
+static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
+{
+    asm volatile("strd %0, %H0, [%1]" : : "r" (val), "r" (addr));
 }
+#define writeq(v,c) ({ __iowmb(); __raw_writeq((__force u64) cpu_to_le64(v), c); })
+#endif
 
 static void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel(BIT(tx_offset) | BIT(rx_offset) |
+           (BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = BIT(rx_offset) | (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= BIT(tx_offset) | (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = BIT(tx_offset) | (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= BIT(rx_offset) | (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel(BIT(tx_offset) | (BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel(BIT(rx_offset) | (BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
 
-	if (IS_ERR_OR_NULL(i2s_tdm->tx_reset) || IS_ERR_OR_NULL(i2s_tdm->rx_reset))
-		return;
-
-	reset_control_assert(i2s_tdm->tx_reset);
-	reset_control_assert(i2s_tdm->rx_reset);
-
-	/* delay for reset assert done */
-	udelay(10);
+    /* delay for reset assert done */
+    udelay(10);
 }
 
 static void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
-		return;
-
-	if (IS_ERR_OR_NULL(i2s_tdm->tx_reset) || IS_ERR_OR_NULL(i2s_tdm->rx_reset))
-		return;
+    int tx_bank, rx_bank, tx_offset, rx_offset, tx_id, rx_id;
+    void __iomem *cru_reset, *addr;
+    unsigned long flags;
+    u64 val;
+
+    if (!i2s_tdm->cru_base || !i2s_tdm->soc_data || !i2s_tdm->is_master_mode)
+    return;
+
+    tx_id = i2s_tdm->tx_reset_id;
+    rx_id = i2s_tdm->rx_reset_id;
+    if (tx_id < 0 || rx_id < 0)
+    return;
+
+    tx_bank = tx_id / 16;
+    tx_offset = tx_id % 16;
+    rx_bank = rx_id / 16;
+    rx_offset = rx_id % 16;
+
+    dev_dbg(i2s_tdm->dev,
+    "tx_bank: %d, rx_bank: %d,tx_offset: %d, rx_offset: %d\n",
+    tx_bank, rx_bank, tx_offset, rx_offset);
+
+    cru_reset = i2s_tdm->cru_base + i2s_tdm->soc_data->softrst_offset;
+    switch (abs(tx_bank - rx_bank)) {
+    case 0:
+    writel((BIT(tx_offset) << 16) | (BIT(rx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    break;
+    case 1:
+    if (tx_bank < rx_bank) {
+        val = (BIT(rx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(tx_offset) << 16);
+        addr = cru_reset + (tx_bank * 4);
+    } else {
+        val = (BIT(tx_offset) << 16);
+        val <<= 32;
+        val |= (BIT(rx_offset) << 16);
+        addr = cru_reset + (rx_bank * 4);
+    }
+    if (IS_ALIGNED((uintptr_t)addr, 8)) {
+        writeq(val, addr);
+        break;
+    }
+    fallthrough;
+    default:
+    local_irq_save(flags);
+    writel((BIT(tx_offset) << 16),
+           cru_reset + (tx_bank * 4));
+    writel((BIT(rx_offset) << 16),
+           cru_reset + (rx_bank * 4));
+    local_irq_restore(flags);
+    break;
+    }
 
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->src_clk_ctrl)
-		i2s_tdm->soc_data->src_clk_ctrl(i2s_tdm, 0);
-
-	reset_control_deassert(i2s_tdm->tx_reset);
-	reset_control_deassert(i2s_tdm->rx_reset);
-
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->src_clk_ctrl)
-		i2s_tdm->soc_data->src_clk_ctrl(i2s_tdm, 1);
+    /* delay for reset deassert done */
+    udelay(10);
+}
 
-	/* delay for reset deassert done */
-	udelay(10);
+/*
+ * make sure both tx and rx are reset at the same time for sync lrck
+ * when clk_trcm > 0
+ */
+static void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
 }
 #else
 static inline void rockchip_i2s_tdm_reset_assert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
 static inline void rockchip_i2s_tdm_reset_deassert(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 }
+
+static inline void rockchip_i2s_tdm_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
+{
+}
 #endif
 
-static void rockchip_i2s_tdm_reset(struct rk_i2s_tdm_dev *i2s_tdm, unsigned int clr)
+static void rockchip_i2s_tdm_reset(struct reset_control *rc)
 {
-	if ((clr & I2S_CLR_TXC) && !IS_ERR_OR_NULL(i2s_tdm->tx_reset)) {
-		reset_control_assert(i2s_tdm->tx_reset);
-		/* delay for reset assert done */
-		udelay(10);
-		reset_control_deassert(i2s_tdm->tx_reset);
-		/* delay for reset deassert done */
-		udelay(10);
-	}
-
-	if ((clr & I2S_CLR_RXC) && !IS_ERR_OR_NULL(i2s_tdm->rx_reset)) {
-		reset_control_assert(i2s_tdm->rx_reset);
-		/* delay for reset assert done */
-		udelay(10);
-		reset_control_deassert(i2s_tdm->rx_reset);
-		/* delay for reset deassert done */
-		udelay(10);
-	}
+    if (IS_ERR_OR_NULL(rc))
+    return;
+
+    reset_control_assert(rc);
+    /* delay for reset assert done */
+    udelay(10);
+
+    reset_control_deassert(rc);
+    /* delay for reset deassert done */
+    udelay(10);
 }
 
 static int rockchip_i2s_tdm_clear(struct rk_i2s_tdm_dev *i2s_tdm,
-				  unsigned int clr)
+      unsigned int clr)
 {
-	unsigned int val = 0;
-	int ret = 0;
+    struct reset_control *rst = NULL;
+    unsigned int val = 0;
+    int ret = 0;
+
+    if (!i2s_tdm->is_master_mode)
+    goto reset;
+
+    switch (clr) {
+    case I2S_CLR_TXC:
+    rst = i2s_tdm->tx_reset;
+    break;
+    case I2S_CLR_RXC:
+    rst = i2s_tdm->rx_reset;
+    break;
+    case I2S_CLR_TXC | I2S_CLR_RXC:
+    break;
+    default:
+    return -EINVAL;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
+
+    ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
+              !(val & clr), 10, 100);
+    if (ret < 0) {
+    dev_warn(i2s_tdm->dev, "failed to clear %u\n", clr);
+    goto reset;
+    }
 
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
-	ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
-					      !(val & clr), 10, 100);
-	if (ret == 0)
-		return 0;
-
-	/*
-	 * Workaround for FIFO clear on SLAVE mode:
-	 *
-	 * A Suggest to do reset hclk domain and then do mclk
-	 *   domain, especially for SLAVE mode without CLK in.
-	 *   at last, recovery regmap config.
-	 *
-	 * B Suggest to switch to MASTER, and then do FIFO clr,
-	 *   at last, bring back to SLAVE.
-	 *
-	 * Now we choose plan B here.
-	 */
-	if (!i2s_tdm->is_master_mode)
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_MSS_MASK, I2S_CKR_MSS_MASTER);
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
-	ret = regmap_read_poll_timeout_atomic(i2s_tdm->regmap, I2S_CLR, val,
-					      !(val & clr), 10, 100);
-	if (!i2s_tdm->is_master_mode)
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_MSS_MASK, I2S_CKR_MSS_SLAVE);
-
-	if (ret < 0) {
-		dev_warn(i2s_tdm->dev, "failed to clear %u on %s mode\n",
-			 clr, i2s_tdm->is_master_mode ? "master" : "slave");
-		goto reset;
-	}
-
-	return 0;
+    return 0;
 
 reset:
-	rockchip_i2s_tdm_reset(i2s_tdm, clr);
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_sync_reset(i2s_tdm);
+    else
+    rockchip_i2s_tdm_reset(rst);
 
-	return 0;
+    return 0;
 }
 
 /*
@@ -554,3024 +645,3251 @@
  */
 static void rockchip_i2s_tdm_tx_fifo_padding(struct rk_i2s_tdm_dev *i2s_tdm, bool en)
 {
-	unsigned int val, w, c, i;
+    unsigned int val, w, c, i;
 
-	if (!en)
-		return;
+    if (!en)
+    return;
 
-	regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-	w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
-	c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    w = ((val & I2S_TXCR_VDW_MASK) >> I2S_TXCR_VDW_SHIFT) + 1;
+    c = to_ch_num(val & I2S_TXCR_CSR_MASK) * w / 32;
 
-	for (i = 0; i < c; i++)
-		regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
+    for (i = 0; i < c; i++)
+    regmap_write(i2s_tdm->regmap, I2S_TXDR, 0x0);
 }
 
 static void rockchip_i2s_tdm_fifo_xrun_detect(struct rk_i2s_tdm_dev *i2s_tdm,
-					      int stream, bool en)
+              int stream, bool en)
 {
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		/* clear irq status which was asserted before TXUIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIE_MASK,
-				   I2S_INTCR_TXUIE(en));
-	} else {
-		/* clear irq status which was asserted before RXOIE enabled */
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIE_MASK,
-				   I2S_INTCR_RXOIE(en));
-	}
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    /* clear irq status which was asserted before TXUIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIE_MASK,
+       I2S_INTCR_TXUIE(en));
+    } else {
+    /* clear irq status which was asserted before RXOIE enabled */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+    /* Disable RX overrun interrupts for external clock mode to reduce CPU load
+     * RX is used only for clock sync, overruns are expected at high sample rates */
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_RXOIE_MASK,
+       I2S_INTCR_RXOIE(0)); /* Force disable RX overrun interrupts */
+    }
 }
 
 static void rockchip_i2s_tdm_dma_ctrl(struct rk_i2s_tdm_dev *i2s_tdm,
-				      int stream, bool en)
-{
-	if (!en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
-			rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
-
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_TDE_MASK,
-				   I2S_DMACR_TDE(en));
-		/*
-		 * Explicitly delay 1 usec for dma to fill FIFO,
-		 * though there was a implied HW delay that around
-		 * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
-		 * to FIFO-pop.
-		 *
-		 * 1 usec is enough to fill at lease 4 entry each FIFO
-		 * @192k 8ch 32bit situation.
-		 */
-		udelay(1);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
-				   I2S_DMACR_RDE_MASK,
-				   I2S_DMACR_RDE(en));
-	}
-
-	if (en)
-		rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
-}
-
-static inline int rockchip_i2s_tdm_clk_assert_h(const struct gpio_desc *desc)
-{
-	int cnt = CLK_MAX_COUNT;
-
-	while (gpiod_get_raw_value(desc) && --cnt)
-		;
-
-	return cnt;
-}
-
-static inline int rockchip_i2s_tdm_clk_assert_l(const struct gpio_desc *desc)
-{
-	int cnt = CLK_MAX_COUNT;
-
-	while (!gpiod_get_raw_value(desc) && --cnt)
-		;
-
-	return cnt;
-}
-
-static inline bool rockchip_i2s_tdm_clk_valid(struct rk_i2s_tdm_dev *i2s_tdm,
-					      bool has_fsync)
-{
-	int dc_h = CLK_MAX_COUNT, dc_l = CLK_MAX_COUNT;
-
-	/*
-	 * TBD: optimize debounce and get value
-	 *
-	 * debounce at least one cycle found, otherwise, the clk ref maybe
-	 * not on the fly.
-	 */
-
-	/* check HIGH-Level */
-	dc_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-	if (!dc_h)
-		return false;
-
-	/* check LOW-Level */
-	dc_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-	if (!dc_l)
-		return false;
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (!has_fsync)
-		return true;
-
-	/* check HIGH-Level */
-	dc_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->tdm_fsync_gpio);
-	if (!dc_h)
-		return false;
-
-	/* check LOW-Level */
-	dc_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->tdm_fsync_gpio);
-	if (!dc_l)
-		return false;
-#endif
-
-	return true;
-}
-
-static void __maybe_unused rockchip_i2s_tdm_gpio_clk_meas(struct rk_i2s_tdm_dev *i2s_tdm,
-							  const struct gpio_desc *desc,
-							  const char *name)
-{
-	int h[NSAMPLES], l[NSAMPLES], i;
-
-	dev_dbg(i2s_tdm->dev, "%s:\n", name);
-
-	if (!rockchip_i2s_tdm_clk_valid(i2s_tdm, 1))
-		return;
-
-	for (i = 0; i < NSAMPLES; i++) {
-		h[i] = rockchip_i2s_tdm_clk_assert_h(desc);
-		l[i] = rockchip_i2s_tdm_clk_assert_l(desc);
-	}
-
-	for (i = 0; i < NSAMPLES; i++)
-		dev_dbg(i2s_tdm->dev, "H[%d]: %2d, L[%d]: %2d\n",
-			i, CLK_MAX_COUNT - h[i], i, CLK_MAX_COUNT - l[i]);
-}
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-static const char * const tx_lanes_text[] = { "Auto", "SDOx1", "SDOx2", "SDOx3", "SDOx4" };
-static const char * const rx_lanes_text[] = { "Auto", "SDIx1", "SDIx2", "SDIx3", "SDIx4" };
-static const struct soc_enum tx_lanes_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(tx_lanes_text), tx_lanes_text);
-static const struct soc_enum rx_lanes_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(rx_lanes_text), rx_lanes_text);
-
-static int rockchip_i2s_tdm_tx_lanes_get(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	ucontrol->value.enumerated.item[0] = i2s_tdm->tx_lanes;
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_tx_lanes_put(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	int num;
-
-	num = ucontrol->value.enumerated.item[0];
-	if (num >= ARRAY_SIZE(tx_lanes_text))
-		return -EINVAL;
-
-	i2s_tdm->tx_lanes = num;
-
-	return 1;
-}
-
-static int rockchip_i2s_tdm_rx_lanes_get(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	ucontrol->value.enumerated.item[0] = i2s_tdm->rx_lanes;
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_rx_lanes_put(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	int num;
-
-	num = ucontrol->value.enumerated.item[0];
-	if (num >= ARRAY_SIZE(rx_lanes_text))
-		return -EINVAL;
-
-	i2s_tdm->rx_lanes = num;
-
-	return 1;
-}
-
-static int rockchip_i2s_tdm_get_lanes(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
-{
-	unsigned int lanes = 1;
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		if (i2s_tdm->tx_lanes)
-			lanes = i2s_tdm->tx_lanes;
-	} else {
-		if (i2s_tdm->rx_lanes)
-			lanes = i2s_tdm->rx_lanes;
-	}
-
-	return lanes;
-}
-
-static struct snd_soc_dai *rockchip_i2s_tdm_find_dai(struct device_node *np)
-{
-	struct snd_soc_dai_link_component dai_component = { 0 };
-
-	dai_component.of_node = np;
-
-	return snd_soc_find_dai_with_mutex(&dai_component);
-}
-
-static int rockchip_i2s_tdm_multi_lanes_set_clk(struct snd_pcm_substream *substream,
-						struct snd_pcm_hw_params *params,
-						struct snd_soc_dai *cpu_dai)
+          int stream, bool en)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
-	struct snd_soc_dai *dai = i2s_tdm->clk_src_dai;
-	unsigned int div, mclk_rate;
-	unsigned int lanes, ch_per_lane;
-
-	lanes = rockchip_i2s_tdm_get_lanes(i2s_tdm, substream->stream);
-	ch_per_lane = params_channels(params) / lanes;
-	mclk_rate = ch_per_lane * params_rate(params) * 32;
-	div = ch_per_lane / 2;
-
-	/* Do nothing when use external clk src */
-	if (dai && dai->driver->ops) {
-		if (dai->driver->ops->set_sysclk)
-			dai->driver->ops->set_sysclk(dai, substream->stream, mclk_rate, 0);
-
-		writel(XFER_DIS, i2s_tdm->clk_src_base + I2S_XFER);
-		writel(CKR_V(64, div, div), i2s_tdm->clk_src_base + I2S_CKR);
-		writel(XFER_EN, i2s_tdm->clk_src_base + I2S_XFER);
-	}
+    if (!en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 0);
 
-	i2s_tdm->lrck_ratio = div;
-	i2s_tdm->mclk_tx_freq = mclk_rate;
-	i2s_tdm->mclk_rx_freq = mclk_rate;
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->quirks & QUIRK_HDMI_PATH)
+        rockchip_i2s_tdm_tx_fifo_padding(i2s_tdm, en);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_TDE_MASK,
+       I2S_DMACR_TDE(en));
+    /*
+     * Explicitly delay 1 usec for dma to fill FIFO,
+     * though there was a implied HW delay that around
+     * half LRCK cycle (e.g. 2.6us@192k) from XFER-start
+     * to FIFO-pop.
+     *
+     * 1 usec is enough to fill at lease 4 entry each FIFO
+     * @192k 8ch 32bit situation.
+     */
+    udelay(1);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR,
+       I2S_DMACR_RDE_MASK,
+       I2S_DMACR_RDE(en));
+    }
 
-	return 0;
+    if (en)
+    rockchip_i2s_tdm_fifo_xrun_detect(i2s_tdm, stream, 1);
 }
 
-static int rockchip_i2s_tdm_fsxn_start(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+static void rockchip_i2s_tdm_xfer_start(struct rk_i2s_tdm_dev *i2s_tdm,
+        int stream)
 {
-	struct gpio_desc *fsn;
-	unsigned int msk, val;
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		fsn = i2s_tdm->fsxn_tx_gpio;
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_START;
-	} else {
-		fsn = i2s_tdm->fsxn_rx_gpio;
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_START;
-	}
-
-	if (!fsn)
-		return -ENODEV;
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
-	udelay(10);
-	gpiod_set_value(fsn, 1);
-
-	return 0;
+    if (i2s_tdm->clk_trcm) {
+    rockchip_i2s_tdm_reset_assert(i2s_tdm);
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK |
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_TXS_START |
+       I2S_XFER_RXS_START);
+    rockchip_i2s_tdm_reset_deassert(i2s_tdm);
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_TXS_MASK,
+       I2S_XFER_TXS_START);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+       I2S_XFER_RXS_MASK,
+       I2S_XFER_RXS_START);
+    }
 }
 
-static int rockchip_i2s_tdm_fsxn_stop(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
-{
-	struct gpio_desc *fsn;
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		fsn = i2s_tdm->fsxn_tx_gpio;
-	else
-		fsn = i2s_tdm->fsxn_rx_gpio;
-
-	if (!fsn)
-		return -ENODEV;
-
-	gpiod_set_value(fsn, 0);
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_multi_lanes_start(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
-{
-	unsigned int tdm_h = 0, tdm_l = 0, i2s_h = 0, i2s_l = 0;
-	unsigned int msk, val, reg, fmt;
-	unsigned long flags;
-	int ret;
-
-	ret = rockchip_i2s_tdm_fsxn_start(i2s_tdm, stream);
-	if (ret == 0)
-		return 0;
-
-	if (!i2s_tdm->tdm_fsync_gpio || !i2s_tdm->i2s_lrck_gpio)
-		return -ENOSYS;
-
-	if (i2s_tdm->lrck_ratio != 4 && i2s_tdm->lrck_ratio != 8)
-		return -EINVAL;
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_START;
-		reg = I2S_TXCR;
-	} else {
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_START;
-		reg = I2S_RXCR;
-	}
-
-	regmap_read(i2s_tdm->regmap, reg, &fmt);
-	fmt = I2S_XCR_IBM_V(fmt);
-
-	local_irq_save(flags);
-
-	if (!rockchip_i2s_tdm_clk_valid(i2s_tdm, 1)) {
-		local_irq_restore(flags);
-		dev_err(i2s_tdm->dev, "Invalid LRCK / FSYNC measured by ref IO\n");
-		return -EINVAL;
-	}
-
-	switch (fmt) {
-	case I2S_XCR_IBM_NORMAL:
-		tdm_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->tdm_fsync_gpio);
-		tdm_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->tdm_fsync_gpio);
-
-		if (i2s_tdm->lrck_ratio == 8) {
-			rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-		}
-
-		i2s_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-
-		if (stream == SNDRV_PCM_STREAM_CAPTURE)
-			i2s_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-		break;
-	case I2S_XCR_IBM_LSJM:
-		tdm_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->tdm_fsync_gpio);
-		tdm_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->tdm_fsync_gpio);
-
-		if (i2s_tdm->lrck_ratio == 8) {
-			rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-			rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-		}
-
-		rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-
-		i2s_l = rockchip_i2s_tdm_clk_assert_l(i2s_tdm->i2s_lrck_gpio);
-		i2s_h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-		break;
-	default:
-		local_irq_restore(flags);
-		return -EINVAL;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
-	local_irq_restore(flags);
-
-	dev_dbg(i2s_tdm->dev, "STREAM[%d]: TDM-H: %d, TDM-L: %d, I2S-H: %d, I2S-L: %d\n", stream,
-		CLK_MAX_COUNT - tdm_h, CLK_MAX_COUNT - tdm_l,
-		CLK_MAX_COUNT - i2s_h, CLK_MAX_COUNT - i2s_l);
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_multi_lanes_parse(struct rk_i2s_tdm_dev *i2s_tdm)
+static void rockchip_i2s_tdm_xfer_stop(struct rk_i2s_tdm_dev *i2s_tdm,
+           int stream, bool force)
 {
-	struct device_node *clk_src_node = NULL;
-	enum gpiod_flags gpiod_flags;
-	unsigned int val;
-	int ret;
+    unsigned int msk, val, clr;
 
-	i2s_tdm->is_tdm_multi_lanes =
-		device_property_read_bool(i2s_tdm->dev, "rockchip,tdm-multi-lanes");
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
+    return;
 
-	if (!i2s_tdm->is_tdm_multi_lanes)
-		return 0;
+    if (i2s_tdm->clk_trcm) {
+    msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
+    val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_TXC | I2S_CLR_RXC;
+    } else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    msk = I2S_XFER_TXS_MASK;
+    val = I2S_XFER_TXS_STOP;
+    clr = I2S_CLR_TXC;
+    } else {
+    msk = I2S_XFER_RXS_MASK;
+    val = I2S_XFER_RXS_STOP;
+    clr = I2S_CLR_RXC;
+    }
 
-	i2s_tdm->tx_lanes = 1;
-	i2s_tdm->rx_lanes = 1;
+    regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
 
-	if (!device_property_read_u32(i2s_tdm->dev, "rockchip,tdm-tx-lanes", &val)) {
-		if ((val >= 1) && (val <= 4))
-			i2s_tdm->tx_lanes = val;
-	}
+    /* delay for LRCK signal integrity */
+    udelay(150);
 
-	if (!device_property_read_u32(i2s_tdm->dev, "rockchip,tdm-rx-lanes", &val)) {
-		if ((val >= 1) && (val <= 4))
-			i2s_tdm->rx_lanes = val;
-	}
-
-	i2s_tdm->fsxn_rx_gpio = devm_gpiod_get_optional(i2s_tdm->dev, "fsxn-rx",
-							GPIOD_OUT_LOW);
-	if (IS_ERR(i2s_tdm->fsxn_rx_gpio)) {
-		ret = PTR_ERR(i2s_tdm->fsxn_rx_gpio);
-		dev_err(i2s_tdm->dev, "Failed to get fsxn_rx_gpio %d\n", ret);
-		return ret;
-	}
-
-	i2s_tdm->fsxn_tx_gpio = devm_gpiod_get_optional(i2s_tdm->dev, "fsxn-tx",
-							GPIOD_OUT_LOW);
-	if (IS_ERR(i2s_tdm->fsxn_tx_gpio)) {
-		ret = PTR_ERR(i2s_tdm->fsxn_tx_gpio);
-		dev_err(i2s_tdm->dev, "Failed to get fsxn_tx_gpio %d\n", ret);
-		return ret;
-	}
-
-	if (i2s_tdm->fsxn_rx_gpio || i2s_tdm->fsxn_tx_gpio)
-		dev_info(i2s_tdm->dev, "FSXN Mode\n");
-
-	/* It's optional, required when use soc clk src, such as: i2s2_2ch */
-	clk_src_node = of_parse_phandle(i2s_tdm->dev->of_node, "rockchip,clk-src", 0);
-	gpiod_flags = clk_src_node ? GPIOD_ASIS : GPIOD_IN;
-	/*
-	 * Two situation for 'tdm-fsync':
-	 *
-	 * A. when the pin is a generic gpio as the ref signal pin which is drived from
-	 *    external. should use flag GPIOD_IN to reclaim as GPIO_IN function.
-	 *
-	 * B. when the pin is the same pin from the 'clk-src' on the same SoC, we can
-	 *    use the 'clk-src' fsync out signal as the 'tdm-fsync' to query status.
-	 *    in this case, should use flag GPIOD_ASIS not to reclaim it as GPIO.
-	 */
-	i2s_tdm->tdm_fsync_gpio = devm_gpiod_get_optional(i2s_tdm->dev, "tdm-fsync",
-							  gpiod_flags);
-	if (IS_ERR(i2s_tdm->tdm_fsync_gpio)) {
-		ret = PTR_ERR(i2s_tdm->tdm_fsync_gpio);
-		dev_err(i2s_tdm->dev, "Failed to get tdm_fsync_gpio %d\n", ret);
-		return ret;
-	}
-
-	if (clk_src_node) {
-		i2s_tdm->clk_src_dai = rockchip_i2s_tdm_find_dai(clk_src_node);
-		if (!i2s_tdm->clk_src_dai)
-			return -EPROBE_DEFER;
-
-		i2s_tdm->clk_src_base = of_iomap(clk_src_node, 0);
-		if (!i2s_tdm->clk_src_base)
-			return -ENOENT;
-
-		pm_runtime_forbid(i2s_tdm->clk_src_dai->dev);
-	}
-
-	dev_info(i2s_tdm->dev, "Used as TDM_MULTI_LANES mode\n");
-
-	return 0;
+    rockchip_i2s_tdm_clear(i2s_tdm, clr);
 }
-#endif
 
-static int rockchip_i2s_tdm_slave_one_frame_start(struct rk_i2s_tdm_dev *i2s_tdm,
-						   int stream)
+static void rockchip_i2s_tdm_xfer_trcm_start(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	unsigned int msk, val, h;
-	unsigned long flags;
-	bool sof;
-
-	sof = i2s_tdm->tdm_mode && !i2s_tdm->is_master_mode &&
-	      !i2s_tdm->tdm_fsync_half_frame;
-
-	if (!sof)
-		return -ENOSYS;
-
-	if (!i2s_tdm->i2s_lrck_gpio) {
-		dev_err(i2s_tdm->dev, "SOF: should assign 'i2s-lrck-gpio' the pin used in DT\n");
-		return -EINVAL;
-	}
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_START;
-	} else {
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_START;
-	}
-
-	local_irq_save(flags);
-	if (!rockchip_i2s_tdm_clk_valid(i2s_tdm, 0)) {
-		local_irq_restore(flags);
-		dev_err(i2s_tdm->dev, "SOF: invalid LRCK, please check 'i2s-lrck-gpio' in DT\n");
-		return -EINVAL;
-	}
-	h = rockchip_i2s_tdm_clk_assert_h(i2s_tdm->i2s_lrck_gpio);
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
-	local_irq_restore(flags);
-
-	dev_dbg(i2s_tdm->dev, "STREAM[%d]: TDM-H: %d\n", stream, CLK_MAX_COUNT - h);
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_xfer_with_gate(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	struct clk *mclk = NULL;
-
-	switch (i2s_tdm->clk_trcm) {
-	case TRCM_TX:
-		mclk = i2s_tdm->mclk_tx;
-		break;
-	case TRCM_RX:
-		mclk = i2s_tdm->mclk_rx;
-		break;
-	default:
-		dev_err(i2s_tdm->dev, "Must use in TRCM mode.\n");
-		return -EINVAL;
-	}
-
-	rockchip_utils_clk_gate_endisable(i2s_tdm->dev, mclk, 0);
-	udelay(10);
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-			   I2S_XFER_TXS_MASK |
-			   I2S_XFER_RXS_MASK,
-			   I2S_XFER_TXS_START |
-			   I2S_XFER_RXS_START);
-	udelay(10);
-	rockchip_utils_clk_gate_endisable(i2s_tdm->dev, mclk, 1);
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_trcm_xfer(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	/* No need to do GATE for HAVE_SYNC_RESET case */
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->src_clk_ctrl)
-		return regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-					  I2S_XFER_TXS_MASK |
-					  I2S_XFER_RXS_MASK,
-					  I2S_XFER_TXS_START |
-					  I2S_XFER_RXS_START);
+    unsigned long flags;
 
-	return rockchip_i2s_tdm_xfer_with_gate(i2s_tdm);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_inc_return(&i2s_tdm->refcount) == 1)
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
-static void rockchip_i2s_tdm_xfer_start(struct rk_i2s_tdm_dev *i2s_tdm,
-					int stream)
+static void rockchip_i2s_tdm_xfer_trcm_stop(struct rk_i2s_tdm_dev *i2s_tdm)
 {
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (i2s_tdm->is_tdm_multi_lanes) {
-		if (rockchip_i2s_tdm_multi_lanes_start(i2s_tdm, stream) != -ENOSYS)
-			return;
-	}
-#endif
-	if (rockchip_i2s_tdm_slave_one_frame_start(i2s_tdm, stream) != -ENOSYS)
-		return;
+    unsigned long flags;
 
-	if (i2s_tdm->clk_trcm) {
-		rockchip_i2s_tdm_reset_assert(i2s_tdm);
-		rockchip_i2s_tdm_trcm_xfer(i2s_tdm);
-		rockchip_i2s_tdm_reset_deassert(i2s_tdm);
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_MASK,
-				   I2S_XFER_TXS_START);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_RXS_MASK,
-				   I2S_XFER_RXS_START);
-	}
-}
-
-static void rockchip_i2s_tdm_xfer_stop(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int stream, bool force)
-{
-	unsigned int msk, val, clr;
-
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !force)
-		return;
-
-	if (i2s_tdm->clk_trcm) {
-		msk = I2S_XFER_TXS_MASK | I2S_XFER_RXS_MASK;
-		val = I2S_XFER_TXS_STOP | I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_TXC | I2S_CLR_RXC;
-	} else if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		msk = I2S_XFER_TXS_MASK;
-		val = I2S_XFER_TXS_STOP;
-		clr = I2S_CLR_TXC;
-	} else {
-		msk = I2S_XFER_RXS_MASK;
-		val = I2S_XFER_RXS_STOP;
-		clr = I2S_CLR_RXC;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, msk, val);
-
-	/* delay for LRCK signal integrity */
-	udelay(150);
-
-	rockchip_i2s_tdm_clear(i2s_tdm, clr);
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	rockchip_i2s_tdm_fsxn_stop(i2s_tdm, stream);
-#endif
-
-	dev_dbg(i2s_tdm->dev, "%s: stream: %d force: %d\n",
-		__func__, stream, force);
-}
-
-static void rockchip_i2s_tdm_xfer_trcm_start(struct rk_i2s_tdm_dev *i2s_tdm,
-					     int stream)
-{
-	int bstream = SNDRV_PCM_STREAM_LAST - stream;
-	unsigned long flags;
-	u32 val, en;
-
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (++i2s_tdm->refcount == 1) {
-		regmap_read(i2s_tdm->regmap, I2S_DMACR, &val);
-		en = I2S_DMACR_RDE(1) | I2S_DMACR_TDE(1);
-		if ((val & en) != en) {
-			rockchip_trcm_dma_guard_ctrl(i2s_tdm, bstream, 1);
-			rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
-		}
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, 0);
-	}
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
-}
-
-static void rockchip_i2s_tdm_xfer_trcm_stop(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int stream)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (--i2s_tdm->refcount == 0)
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_dec_and_test(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, 0, false);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_i2s_tdm_trcm_pause(struct snd_pcm_substream *substream,
-					struct rk_i2s_tdm_dev *i2s_tdm)
+        struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int stream = substream->stream;
-	int bstream = SNDRV_PCM_STREAM_LAST - stream;
-
-	if (i2s_tdm->pcm_comp)
-		rockchip_trcm_dma_guard_ctrl(i2s_tdm, stream, 0);
-
-	/* store the current state, prepare for resume if necessary */
-	i2s_tdm->is_dma_active[bstream] = is_dma_active(i2s_tdm, bstream);
+    int stream = substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - stream;
 
-	/* disable dma for both tx and rx */
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
-	rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
+    /* disable dma for both tx and rx */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 0);
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, bstream, true);
 }
 
 static void rockchip_i2s_tdm_trcm_resume(struct snd_pcm_substream *substream,
-					 struct rk_i2s_tdm_dev *i2s_tdm)
+         struct rk_i2s_tdm_dev *i2s_tdm)
 {
-	int stream = substream->stream;
-	int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
+    int bstream = SNDRV_PCM_STREAM_LAST - substream->stream;
 
-	if (i2s_tdm->pcm_comp) {
-		rockchip_trcm_dma_guard_ctrl(i2s_tdm, stream, 1);
-		rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
-	}
-
-	if (i2s_tdm->is_dma_active[bstream])
-		rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
+    /*
+     * just resume bstream, because current stream will be
+     * startup in the trigger-cmd-START
+     */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, bstream, 1);
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+}
 
-	rockchip_i2s_tdm_xfer_start(i2s_tdm, bstream);
+/* Additional function to check pause state */
+static bool rockchip_i2s_tdm_is_paused(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+    return i2s_tdm->playback_paused;
+    else
+    return i2s_tdm->capture_paused;
 }
 
 static void rockchip_i2s_tdm_start(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	/*
-	 * On HDMI-PATH-ALWAYS-ON situation, we almost keep XFER always on,
-	 * so, for new data start, suggested to STOP-CLEAR-START to make sure
-	 * data aligned.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-	}
-
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
-
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm, stream);
-	else
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    /* Check if stream is in pause state */
+    if (rockchip_i2s_tdm_is_paused(i2s_tdm, stream)) {
+    dev_dbg(i2s_tdm->dev, "Stream is paused, not starting\n");
+    return;
+    }
+
+    /* Note: Mute is now handled in trigger with proper delayed start timing */
+
+    /* Always start DMA and transmission */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
+    
+    if (i2s_tdm->clk_trcm)
+    rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, stream);
+    
+    /* Check mute */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK && i2s_tdm->mute) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback started with mute\n");
+    /* DO NOT disable DMA when muted - let GPIO mute do its job */
+    /* rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0); */
+    }
 }
 
 static void rockchip_i2s_tdm_stop(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
 {
-	rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    /* Mute is handled in trigger callback */
+    
+    /* First stop transmission (BCLK/DATA), then DMA */
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm);
+    else
+        rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
+    
+    /* Then stop DMA */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    /* Only logging, no mute state change */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    dev_dbg(i2s_tdm->dev, "ROCKCHIP_I2S_TDM: Playback stopped, mute state: %s\n", 
+        i2s_tdm->mute ? "enabled" : "disabled");
+    }
+}
+
+/* New functions for pause/resume handling */
+static void rockchip_i2s_tdm_pause(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = true;
+    } else {
+    if (i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = true;
+    }
+
+    /* Disable DMA but preserve device state */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 0);
+    
+    /* Use special function for TRCM mode */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+    } else {
+    /* For normal mode, pause transmission */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_STOP);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_STOP);
+    }
+    }
+
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream paused\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
+}
+
+static void rockchip_i2s_tdm_resume(struct rk_i2s_tdm_dev *i2s_tdm, int stream)
+{
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    if (!i2s_tdm->playback_paused)
+        return;
+    i2s_tdm->playback_paused = false;
+    } else {
+    if (!i2s_tdm->capture_paused)
+        return;
+    i2s_tdm->capture_paused = false;
+    }
+
+    /* Use special function for TRCM mode */
+    if (i2s_tdm->clk_trcm) {
+    struct snd_pcm_substream *substream = i2s_tdm->substreams[stream];
+    if (substream)
+        rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    } else {
+    /* Restore data transmission */
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_TXS_MASK,
+           I2S_XFER_TXS_START);
+    } else {
+        regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+           I2S_XFER_RXS_MASK,
+           I2S_XFER_RXS_START);
+    }
+    }
 
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_trcm_stop(i2s_tdm, stream);
-	else
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, false);
-}
-
-static int rockchip_i2s_tdm_parse_channels(struct rk_i2s_tdm_dev *i2s_tdm,
-					   int stream, int channels)
-{
-	unsigned int reg_fmt, fmt;
-	int ret = 0;
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (i2s_tdm->is_tdm_multi_lanes) {
-		unsigned int lanes = rockchip_i2s_tdm_get_lanes(i2s_tdm, stream);
-
-		switch (lanes) {
-		case 4:
-			ret = I2S_CHN_8;
-			break;
-		case 3:
-			ret = I2S_CHN_6;
-			break;
-		case 2:
-			ret = I2S_CHN_4;
-			break;
-		case 1:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
+    /* Enable DMA */
+    rockchip_i2s_tdm_dma_ctrl(i2s_tdm, stream, 1);
 
-		return ret;
-	}
-#endif
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		reg_fmt = I2S_TXCR;
-	else
-		reg_fmt = I2S_RXCR;
-
-	regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
-	fmt &= I2S_TXCR_TFS_MASK;
-
-	if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-		switch (channels) {
-		case 16:
-			ret = I2S_CHN_8;
-			break;
-		case 12:
-			ret = I2S_CHN_6;
-			break;
-		case 8:
-			ret = I2S_CHN_4;
-			break;
-		case 4:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	} else {
-		switch (channels) {
-		case 8:
-			ret = I2S_CHN_8;
-			break;
-		case 6:
-			ret = I2S_CHN_6;
-			break;
-		case 4:
-			ret = I2S_CHN_4;
-			break;
-		case 2:
-			ret = I2S_CHN_2;
-			break;
-		default:
-			ret = -EINVAL;
-			break;
-		}
-	}
-
-	return ret;
+    dev_dbg(i2s_tdm->dev, "I2S/TDM %s stream resumed\n",
+    stream == SNDRV_PCM_STREAM_PLAYBACK ? "playback" : "capture");
 }
 
 static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
-				    unsigned int fmt)
+        unsigned int fmt)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
-	unsigned int mask, val, tdm_val, txcr_val, rxcr_val;
-	int ret;
-	bool is_tdm = i2s_tdm->tdm_mode;
-
-	ret = pm_runtime_resume_and_get(cpu_dai->dev);
-	if (ret < 0 && ret != -EACCES)
-		return ret;
-
-	mask = I2S_CKR_MSS_MASK;
-	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
-	case SND_SOC_DAIFMT_BP_FP:
-		val = I2S_CKR_MSS_MASTER;
-		i2s_tdm->is_master_mode = true;
-		break;
-	case SND_SOC_DAIFMT_BC_FC:
-		val = I2S_CKR_MSS_SLAVE;
-		i2s_tdm->is_master_mode = false;
-		/*
-		 * TRCM require TX/RX enabled at the same time, or need the one
-		 * which provide clk enabled at first for master mode.
-		 *
-		 * It is quite a different for slave mode which does not have
-		 * these restrictions, because the BCLK / LRCK are provided by
-		 * external master devices.
-		 *
-		 * So, we just set the right clk path value on TRCM register on
-		 * stage probe and then drop the trcm value to make TX / RX work
-		 * independently.
-		 */
-		i2s_tdm->clk_trcm = 0;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
-	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
-	case SND_SOC_DAIFMT_NB_NF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_NB_IF:
-		val = I2S_CKR_CKP_NORMAL |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	case SND_SOC_DAIFMT_IB_NF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_NORMAL |
-		      I2S_CKR_RLP_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_IB_IF:
-		val = I2S_CKR_CKP_INVERTED |
-		      I2S_CKR_TLP_INVERTED |
-		      I2S_CKR_RLP_INVERTED;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
-
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		txcr_val = I2S_TXCR_IBM_RSJM;
-		rxcr_val = I2S_RXCR_IBM_RSJM;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		txcr_val = I2S_TXCR_IBM_LSJM;
-		rxcr_val = I2S_RXCR_IBM_LSJM;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		txcr_val = I2S_TXCR_IBM_NORMAL;
-		rxcr_val = I2S_RXCR_IBM_NORMAL;
-		break;
-	case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
-		txcr_val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
-		rxcr_val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
-		break;
-	case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
-		txcr_val = I2S_TXCR_TFS_PCM;
-		rxcr_val = I2S_RXCR_TFS_PCM;
-		break;
-	default:
-		ret = -EINVAL;
-		goto err_pm_put;
-	}
-
-	mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
-	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, txcr_val);
-
-	mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
-	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, rxcr_val);
-
-	if (is_tdm) {
-		switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-		case SND_SOC_DAIFMT_RIGHT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_LEFT_J:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(1);
-			break;
-		case SND_SOC_DAIFMT_I2S:
-			val = I2S_TXCR_TFS_TDM_I2S;
-			tdm_val = TDM_SHIFT_CTRL(0);
-			break;
-		case SND_SOC_DAIFMT_DSP_A:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(2);
-			break;
-		case SND_SOC_DAIFMT_DSP_B:
-			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(4);
-			break;
-		default:
-			ret = -EINVAL;
-			goto err_pm_put;
-		}
-
-		tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
-		if (i2s_tdm->tdm_fsync_half_frame)
-			tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
-		else
-			tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
-
-		mask = I2S_TXCR_TFS_MASK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-
-		mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
-		       TDM_SHIFT_CTRL_MSK;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-				   mask, tdm_val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-				   mask, tdm_val);
-
-		if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
-			/* refine frame width for TDM_I2S_ONE_FRAME */
-			mask = TDM_FRAME_WIDTH_MSK;
-			tdm_val = TDM_FRAME_WIDTH(i2s_tdm->frame_width >> 1);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
-					   mask, tdm_val);
-			regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
-					   mask, tdm_val);
-		}
-
-		mask = I2S_TXCR_CSR_MASK;
-		ret = rockchip_i2s_tdm_parse_channels(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK,
-						      i2s_tdm->tdm_slots);
-		if (ret < 0) {
-			dev_err(i2s_tdm->dev, "Invalid slots: %d\n", i2s_tdm->tdm_slots);
-			return ret;
-		}
-
-		val = ret;
-		ret = 0;
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-	}
-
-	/* Enable the xfer in the last card init stage. */
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON && !i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    unsigned int mask = 0, val = 0, tdm_val = 0;
+    int ret = 0;
+    bool is_tdm = i2s_tdm->tdm_mode;
+
+    pm_runtime_get_sync(cpu_dai->dev);
+    
+    /* Save format for forced changes application */
+    i2s_tdm->format = fmt;
+
+    mask = I2S_CKR_MSS_MASK;
+    dev_info(cpu_dai->dev, "set_fmt called: fmt=0x%x, master_mask=0x%x\n", 
+             fmt, fmt & SND_SOC_DAIFMT_MASTER_MASK);
+    
+    switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+    case SND_SOC_DAIFMT_CBS_CFS:
+    val = I2S_CKR_MSS_MASTER;
+    i2s_tdm->is_master_mode = true;
+    dev_info(cpu_dai->dev, "Setting MASTER mode (CBS_CFS)\n");
+    break;
+    case SND_SOC_DAIFMT_CBM_CFM:
+    /* Force master mode if mclk_calibrate or mclk_external is enabled (kernel 6.1 fix) */
+    if (i2s_tdm->mclk_calibrate || i2s_tdm->mclk_external) {
+        val = I2S_CKR_MSS_MASTER;
+        i2s_tdm->is_master_mode = true;
+        if (i2s_tdm->mclk_calibrate)
+            dev_info(cpu_dai->dev, "Forcing MASTER mode for mclk_calibrate (was CBM_CFM)\n");
+        else
+            dev_info(cpu_dai->dev, "Forcing MASTER mode for mclk_external (was CBM_CFM)\n");
+    } else {
+        val = I2S_CKR_MSS_SLAVE;
+        i2s_tdm->is_master_mode = false;
+        dev_info(cpu_dai->dev, "Setting SLAVE mode (CBM_CFM)\n");
+    }
+    break;
+    default:
+    dev_err(cpu_dai->dev, "Unknown master mode: 0x%x\n", fmt & SND_SOC_DAIFMT_MASTER_MASK);
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+    dev_info(cpu_dai->dev, "Applied MSS to CKR: val=0x%x\n", val);
+
+    mask = I2S_CKR_CKP_MASK | I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+    switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+    case SND_SOC_DAIFMT_NB_NF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_NB_IF:
+    val = I2S_CKR_CKP_NORMAL |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    case SND_SOC_DAIFMT_IB_NF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_NORMAL |
+          I2S_CKR_RLP_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_IB_IF:
+    val = I2S_CKR_CKP_INVERTED |
+          I2S_CKR_TLP_INVERTED |
+          I2S_CKR_RLP_INVERTED;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    /* Apply PCM channel swap if enabled and not in DSD mode */
+    if (i2s_tdm->pcm_channel_swap && !i2s_tdm->dsd_mode_active) {
+        /* Invert LRCK polarity for channel switching */
+        bool was_inverted = (val & I2S_CKR_TLP_INVERTED) != 0;
+        val &= ~(I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK);
+        if (was_inverted) {
+            val |= I2S_CKR_TLP_NORMAL | I2S_CKR_RLP_NORMAL;
+        } else {
+            val |= I2S_CKR_TLP_INVERTED | I2S_CKR_RLP_INVERTED;
+        }
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, val);
+
+
+    mask = I2S_TXCR_IBM_MASK | I2S_TXCR_TFS_MASK | I2S_TXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_TXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_TXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_TXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_TXCR_TFS_PCM | I2S_TXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_TXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+
+    mask = I2S_RXCR_IBM_MASK | I2S_RXCR_TFS_MASK | I2S_RXCR_PBM_MASK;
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+    val = I2S_RXCR_IBM_RSJM;
+    break;
+    case SND_SOC_DAIFMT_LEFT_J:
+    val = I2S_RXCR_IBM_LSJM;
+    break;
+    case SND_SOC_DAIFMT_I2S:
+    val = I2S_RXCR_IBM_NORMAL;
+    break;
+    case SND_SOC_DAIFMT_DSP_A: /* PCM delay 1 mode */
+    val = I2S_RXCR_TFS_PCM | I2S_RXCR_PBM_MODE(1);
+    break;
+    case SND_SOC_DAIFMT_DSP_B: /* PCM no delay mode */
+    val = I2S_RXCR_TFS_PCM;
+    break;
+    default:
+    ret = -EINVAL;
+    goto err_pm_put;
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    if (is_tdm) {
+    switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+    case SND_SOC_DAIFMT_RIGHT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_LEFT_J:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(1);
+        break;
+    case SND_SOC_DAIFMT_I2S:
+        val = I2S_TXCR_TFS_TDM_I2S;
+        tdm_val = TDM_SHIFT_CTRL(0);
+        break;
+    case SND_SOC_DAIFMT_DSP_A:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(2);
+        break;
+    case SND_SOC_DAIFMT_DSP_B:
+        val = I2S_TXCR_TFS_TDM_PCM;
+        tdm_val = TDM_SHIFT_CTRL(4);
+        break;
+    default:
+        ret = -EINVAL;
+        goto err_pm_put;
+    }
+
+    tdm_val |= TDM_FSYNC_WIDTH_SEL1(1);
+    if (i2s_tdm->tdm_fsync_half_frame)
+        tdm_val |= TDM_FSYNC_WIDTH_HALF_FRAME;
+    else
+        tdm_val |= TDM_FSYNC_WIDTH_ONE_FRAME;
+
+    mask = I2S_TXCR_TFS_MASK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
+
+    mask = TDM_FSYNC_WIDTH_SEL1_MSK | TDM_FSYNC_WIDTH_SEL0_MSK |
+           TDM_SHIFT_CTRL_MSK;
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+       mask, tdm_val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+       mask, tdm_val);
+
+    if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+        /* refine frame width for TDM_I2S_ONE_FRAME */
+        mask = TDM_FRAME_WIDTH_MSK;
+        tdm_val = TDM_FRAME_WIDTH(i2s_tdm->bclk_fs >> 1);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, tdm_val);
+        regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, tdm_val);
+    }
+    }
 
 err_pm_put:
-	pm_runtime_put(cpu_dai->dev);
+    pm_runtime_put(cpu_dai->dev);
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_clk_set_rate(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct clk *clk, unsigned long rate,
-					 int ppm)
+         struct clk *clk, unsigned long rate,
+         int ppm)
 {
-	unsigned long rate_target;
-	int delta, ret;
+    unsigned long rate_target;
+    int delta, ret;
 
-	if (ppm == i2s_tdm->clk_ppm)
-		return 0;
+    if (ppm == i2s_tdm->clk_ppm)
+    return 0;
 
-	ret = rockchip_pll_clk_compensation(clk, ppm);
-	if (ret != -ENOSYS)
-		goto out;
+    ret = rockchip_pll_clk_compensation(clk, ppm);
+    if (ret != -ENOSYS)
+    goto out;
 
-	delta = (ppm < 0) ? -1 : 1;
-	delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
+    delta = (ppm < 0) ? -1 : 1;
+    delta *= (int)div64_u64((uint64_t)rate * (uint64_t)abs(ppm) + 500000, 1000000);
 
-	rate_target = rate + delta;
+    rate_target = rate + delta;
+    if (!rate_target)
+    return -EINVAL;
 
-	if (!rate_target)
-		return -EINVAL;
+    ret = clk_set_rate(clk, rate_target);
+    if (ret)
+    return ret;
 
-	ret = clk_set_rate(clk, rate_target);
-	if (ret)
-		return ret;
 out:
-	if (!ret)
-		i2s_tdm->clk_ppm = ppm;
+    if (!ret)
+    i2s_tdm->clk_ppm = ppm;
 
-	return ret;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_calibrate_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-					   struct snd_pcm_substream *substream,
-					   unsigned int lrck_freq)
+           struct snd_pcm_substream *substream,
+           unsigned int lrck_freq)
 {
-	struct clk *mclk_root;
-	struct clk *mclk_parent;
-	unsigned int mclk_root_freq;
-	unsigned int mclk_root_initial_freq;
-	unsigned int mclk_parent_freq;
-	unsigned int mclk_freq, freq, freq_req;
-	unsigned int div, delta;
-	u64 ppm;
-	int ret;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		mclk_parent = i2s_tdm->mclk_tx_src;
-		mclk_freq = i2s_tdm->mclk_tx_freq;
-	} else {
-		mclk_parent = i2s_tdm->mclk_rx_src;
-		mclk_freq = i2s_tdm->mclk_rx_freq;
-	}
-
-	switch (i2s_tdm->clk_trcm) {
-	case TRCM_TX:
-		mclk_parent = i2s_tdm->mclk_tx_src;
-		mclk_freq = i2s_tdm->mclk_tx_freq;
-		break;
-	case TRCM_RX:
-		mclk_parent = i2s_tdm->mclk_rx_src;
-		mclk_freq = i2s_tdm->mclk_rx_freq;
-		break;
-	}
-
-	switch (lrck_freq) {
-	case 8000:
-	case 16000:
-	case 24000:
-	case 32000:
-	case 48000:
-	case 64000:
-	case 96000:
-	case 192000:
-		mclk_root = i2s_tdm->mclk_root0;
-		mclk_root_freq = i2s_tdm->mclk_root0_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root0_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 192000;
-		break;
-	case 11025:
-	case 22050:
-	case 44100:
-	case 88200:
-	case 176400:
-		mclk_root = i2s_tdm->mclk_root1;
-		mclk_root_freq = i2s_tdm->mclk_root1_freq;
-		mclk_root_initial_freq = i2s_tdm->mclk_root1_initial_freq;
-		mclk_parent_freq = DEFAULT_MCLK_FS * 176400;
-		break;
-	default:
-		dev_err(i2s_tdm->dev, "Invalid LRCK frequency: %u Hz\n",
-			lrck_freq);
-		return -EINVAL;
-	}
-
-	ret = clk_set_parent(mclk_parent, mclk_root);
-	if (ret)
-		return ret;
-
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, mclk_root,
-					    mclk_root_freq, 0);
-	if (ret)
-		return ret;
-
-	delta = abs(mclk_root_freq % mclk_parent_freq - mclk_parent_freq);
-	ppm = div64_u64((uint64_t)delta * 1000000, (uint64_t)mclk_root_freq);
-
-	if (ppm) {
-		div = DIV_ROUND_CLOSEST(mclk_root_initial_freq, mclk_parent_freq);
-		if (!div)
-			return -EINVAL;
-
-		mclk_root_freq = mclk_parent_freq * round_up(div, 2);
-
-		ret = clk_set_rate(mclk_root, mclk_root_freq);
-		if (ret)
-			return ret;
-
-		i2s_tdm->mclk_root0_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_freq = clk_get_rate(i2s_tdm->mclk_root1);
-	}
-
-	freq = clk_get_rate(mclk_parent);
-	div = DIV_ROUND_CLOSEST(freq, mclk_freq);
-	freq_req = mclk_freq * div;
-	if (freq < freq_req - CLK_SHIFT_RATE_HZ_MAX ||
-	    freq > freq_req + CLK_SHIFT_RATE_HZ_MAX) {
-		dev_dbg(i2s_tdm->dev, "Change mclk parent freq from %d to %d\n",
-			freq, mclk_parent_freq);
-		ret = clk_set_rate(mclk_parent, mclk_parent_freq);
-	}
-
-	return ret;
-}
-
-static int rockchip_i2s_tdm_mclk_reparent(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	struct clk *parent;
-	int ret = 0;
-
-	/* reparent to the same clk on TRCM mode */
-	switch (i2s_tdm->clk_trcm) {
-	case TRCM_TX:
-		parent = clk_get_parent(i2s_tdm->mclk_tx);
-		/*
-		 * API clk_has_parent is not available yet on GKI, so we
-		 * use clk_set_parent directly and ignore the ret value.
-		 * if the API has addressed on GKI, should remove it.
-		 */
-#ifdef CONFIG_NO_GKI
-		if (clk_has_parent(i2s_tdm->mclk_rx, parent))
-			ret = clk_set_parent(i2s_tdm->mclk_rx, parent);
-#else
-		clk_set_parent(i2s_tdm->mclk_rx, parent);
-#endif
-		break;
-	case TRCM_RX:
-		parent = clk_get_parent(i2s_tdm->mclk_rx);
-#ifdef CONFIG_NO_GKI
-		if (clk_has_parent(i2s_tdm->mclk_tx, parent))
-			ret = clk_set_parent(i2s_tdm->mclk_tx, parent);
-#else
-		clk_set_parent(i2s_tdm->mclk_tx, parent);
-#endif
-		break;
-	}
+    struct clk *mclk_root;
+    struct clk *mclk_parent;
+    unsigned int target_mclk, pll_freq, src_freq, ideal_pll;
+    unsigned int div;
+    int ret;
+
+    if (i2s_tdm->mclk_external) {
+        dev_info(i2s_tdm->dev, "MCLK calibrate: skipped (external clock mode)\n");
+        return 0;
+    }
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    mclk_parent = i2s_tdm->mclk_tx_src;
+    else
+    mclk_parent = i2s_tdm->mclk_rx_src;
+
+    mclk_root = clk_get_parent(mclk_parent);
+    if (!mclk_root) {
+        dev_err(i2s_tdm->dev, "Failed to get parent clock\n");
+        ret = -EINVAL;
+        goto out;
+    }
+    
+    target_mclk = i2s_tdm->mclk_multiplier * lrck_freq;
+    
+    mclk_root = clk_get_parent(mclk_parent);
+    pll_freq = clk_get_rate(mclk_root);
+    
+    if (lrck_freq % 44100 == 0) {
+        ideal_pll = 993484800;
+        src_freq = 45158400;
+    } else if (lrck_freq % 48000 == 0) {
+        ideal_pll = 983040000;
+        src_freq = 49152000;
+    } else {
+        ideal_pll = 983040000;
+        src_freq = 49152000;
+    }
+    
+    dev_info(i2s_tdm->dev, "Current PLL: %u Hz, target: %u Hz (for %u Hz family, target SRC=%u Hz)\n",
+             pll_freq, ideal_pll, lrck_freq, src_freq);
+    
+    if (pll_freq != ideal_pll) {
+        ret = clk_set_rate(mclk_root, ideal_pll);
+        if (ret == 0) {
+            pll_freq = clk_get_rate(mclk_root);
+            dev_info(i2s_tdm->dev, "PLL changed to: %u Hz\n", pll_freq);
+        }
+    }
+    
+    ret = clk_set_rate(mclk_parent, src_freq);
+    if (ret) {
+        dev_err(i2s_tdm->dev, "Failed to set SRC to %u Hz: %d\n", src_freq, ret);
+        goto out;
+    }
+    
+    src_freq = clk_get_rate(mclk_parent);
+    div = pll_freq / src_freq;
 
-	return ret;
+    dev_info(i2s_tdm->dev, "Clock config: PLL=%u Hz %u  SRC=%u Hz (%s family, %ux multiplier)\n",
+         pll_freq, div, src_freq, (lrck_freq % 44100 == 0) ? "44.1k" : "48k", i2s_tdm->mclk_multiplier);
+
+out:
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_mclk(struct rk_i2s_tdm_dev *i2s_tdm,
-				     struct snd_pcm_substream *substream,
-				     struct clk **mclk)
+         struct snd_pcm_substream *substream,
+         struct clk **mclk)
 {
-	unsigned int mclk_freq;
-	int ret;
+    unsigned int mclk_freq;
+    int ret;
+
+    if (i2s_tdm->clk_trcm) {
+    if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
+        dev_err(i2s_tdm->dev,
+    "clk_trcm, tx: %d and rx: %d should be same\n",
+    i2s_tdm->mclk_tx_freq,
+    i2s_tdm->mclk_rx_freq);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    /* Skip clk_set_rate when mclk_calibrate or mclk_external is enabled */
+    if (!i2s_tdm->mclk_calibrate && !i2s_tdm->mclk_external) {
+        ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
+        if (ret)
+            goto err;
+
+        ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
+        if (ret)
+            goto err;
+    } else {
+        if (i2s_tdm->mclk_calibrate)
+            dev_info(i2s_tdm->dev, "Skipping clk_set_rate (mclk_calibrate active, TX_SRC=%lu Hz)\n",
+                     clk_get_rate(i2s_tdm->mclk_tx_src));
+        else
+            dev_info(i2s_tdm->dev, "Skipping clk_set_rate (mclk_external active, MCLK=%lu Hz)\n",
+                     clk_get_rate(i2s_tdm->mclk_tx));
+    }
+
+    /* mclk_rx is also ok. */
+    *mclk = i2s_tdm->mclk_tx;
+    } else {
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        *mclk = i2s_tdm->mclk_tx;
+        mclk_freq = i2s_tdm->mclk_tx_freq;
+    } else {
+        *mclk = i2s_tdm->mclk_rx;
+        mclk_freq = i2s_tdm->mclk_rx_freq;
+    }
+
+    ret = clk_set_rate(*mclk, mclk_freq);
+    if (ret)
+        goto err;
+    }
 
-	if (i2s_tdm->clk_trcm) {
-		if (i2s_tdm->mclk_tx_freq != i2s_tdm->mclk_rx_freq) {
-			dev_err(i2s_tdm->dev,
-				"clk_trcm, tx: %d and rx: %d should be the same\n",
-				i2s_tdm->mclk_tx_freq,
-				i2s_tdm->mclk_rx_freq);
-			return -EINVAL;
-		}
-
-		ret = clk_set_rate(i2s_tdm->mclk_tx, i2s_tdm->mclk_tx_freq);
-		if (ret)
-			return ret;
-
-		ret = clk_set_rate(i2s_tdm->mclk_rx, i2s_tdm->mclk_rx_freq);
-		if (ret)
-			return ret;
-
-		ret = rockchip_i2s_tdm_mclk_reparent(i2s_tdm);
-		if (ret)
-			return ret;
-
-		/* mclk_rx is also ok. */
-		*mclk = i2s_tdm->mclk_tx;
-	} else {
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-			*mclk = i2s_tdm->mclk_tx;
-			mclk_freq = i2s_tdm->mclk_tx_freq;
-		} else {
-			*mclk = i2s_tdm->mclk_rx;
-			mclk_freq = i2s_tdm->mclk_rx_freq;
-		}
-
-		ret = clk_set_rate(*mclk, mclk_freq);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int rockchip_i2s_ch_to_io(unsigned int ch, bool substream_capture)
-{
-	if (substream_capture) {
-		switch (ch) {
-		case I2S_CHN_4:
-			return I2S_IO_6CH_OUT_4CH_IN;
-		case I2S_CHN_6:
-			return I2S_IO_4CH_OUT_6CH_IN;
-		case I2S_CHN_8:
-			return I2S_IO_2CH_OUT_8CH_IN;
-		default:
-			return I2S_IO_8CH_OUT_2CH_IN;
-		}
-	} else {
-		switch (ch) {
-		case I2S_CHN_4:
-			return I2S_IO_4CH_OUT_6CH_IN;
-		case I2S_CHN_6:
-			return I2S_IO_6CH_OUT_4CH_IN;
-		case I2S_CHN_8:
-			return I2S_IO_8CH_OUT_2CH_IN;
-		default:
-			return I2S_IO_2CH_OUT_8CH_IN;
-		}
-	}
+    return 0;
+
+err:
+    return ret;
 }
 
 static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
-				     struct snd_soc_dai *dai)
+         struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int usable_chs = MULTIPLEX_CH_MAX;
-	unsigned int val = 0;
-
-	if (!i2s_tdm->io_multiplex)
-		return 0;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
-		struct snd_pcm_str *playback_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
-
-		if (playback_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-			val &= I2S_TXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		val &= I2S_RXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Capture channels (%d) > usable channels (%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-
-		rockchip_i2s_ch_to_io(val, true);
-	} else {
-		struct snd_pcm_str *capture_str =
-			&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
-
-		if (capture_str->substream_opened) {
-			regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-			val &= I2S_RXCR_CSR_MASK;
-			usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
-		}
-
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		val &= I2S_TXCR_CSR_MASK;
-
-		if (to_ch_num(val) > usable_chs) {
-			dev_err(i2s_tdm->dev,
-				"Playback channels (%d) > usable channels (%d)\n",
-				to_ch_num(val), usable_chs);
-			return -EINVAL;
-		}
-	}
-
-	val <<= i2s_tdm->soc_data->grf_shift;
-	val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
-	regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int usable_chs = MULTIPLEX_CH_MAX;
+    unsigned int val = 0;
+
+    if (!i2s_tdm->io_multiplex)
+    return 0;
+
+    if (IS_ERR(i2s_tdm->grf))
+    return 0;
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+    struct snd_pcm_str *playback_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK];
+
+    if (playback_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+        val &= I2S_TXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    val &= I2S_RXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Capture chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    default:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    }
+    } else {
+    struct snd_pcm_str *capture_str =
+        &substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
+
+    if (capture_str->substream_opened) {
+        regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+        val &= I2S_RXCR_CSR_MASK;
+        usable_chs = MULTIPLEX_CH_MAX - to_ch_num(val);
+    }
+
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    val &= I2S_TXCR_CSR_MASK;
+
+    if (to_ch_num(val) > usable_chs) {
+        dev_err(i2s_tdm->dev,
+    "Playback chs(%d) > usable chs(%d)\n",
+    to_ch_num(val), usable_chs);
+        return -EINVAL;
+    }
+
+    switch (val) {
+    case I2S_CHN_4:
+        val = I2S_IO_4CH_OUT_6CH_IN;
+        break;
+    case I2S_CHN_6:
+        val = I2S_IO_6CH_OUT_4CH_IN;
+        break;
+    case I2S_CHN_8:
+        val = I2S_IO_8CH_OUT_2CH_IN;
+        break;
+    default:
+        val = I2S_IO_2CH_OUT_8CH_IN;
+        break;
+    }
+    }
+
+    val <<= i2s_tdm->soc_data->grf_shift;
+    val |= (I2S_IO_DIRECTION_MASK << i2s_tdm->soc_data->grf_shift) << 16;
+    regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
 
-	return 0;
+    return 0;
 }
 
 static bool is_params_dirty(struct snd_pcm_substream *substream,
-			    struct snd_soc_dai *dai,
-			    unsigned int div_bclk,
-			    unsigned int div_lrck,
-			    unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
-
-	regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
-	last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
-	if (last_div_bclk != div_bclk)
-		return true;
-
-	if (i2s_tdm->tdm_mode) {
-		regmap_read(i2s_tdm->regmap,
-			    substream->stream ? I2S_TDM_RXCR : I2S_TDM_TXCR, &val);
-		last_div_lrck = TDM_FRAME_WIDTH_V(val);
-
-		regmap_read(i2s_tdm->regmap,
-			    substream->stream ? I2S_RXCR : I2S_TXCR, &val);
-		val &= I2S_TXCR_TFS_MASK;
-		if (val == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame)
-			last_div_lrck <<= 1;
-	} else {
-		regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
-		last_div_lrck = I2S_CKR_TSD_V(val);
-	}
-	if (last_div_lrck != div_lrck)
-		return true;
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
-		last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
-	} else {
-		regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
-		last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
-	}
-	if (last_fmt != fmt)
-		return true;
+            struct snd_soc_dai *dai,
+            unsigned int div_bclk,
+            unsigned int div_lrck,
+            unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int last_div_bclk, last_div_lrck, last_fmt, val;
+
+    regmap_read(i2s_tdm->regmap, I2S_CLKDIV, &val);
+    last_div_bclk = ((val & I2S_CLKDIV_TXM_MASK) >> I2S_CLKDIV_TXM_SHIFT) + 1;
+    if (last_div_bclk != div_bclk)
+    return true;
+
+    regmap_read(i2s_tdm->regmap, I2S_CKR, &val);
+    last_div_lrck = ((val & I2S_CKR_TSD_MASK) >> I2S_CKR_TSD_SHIFT) + 1;
+    if (last_div_lrck != div_lrck)
+    return true;
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_read(i2s_tdm->regmap, I2S_TXCR, &val);
+    last_fmt = val & (I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK);
+    } else {
+    regmap_read(i2s_tdm->regmap, I2S_RXCR, &val);
+    last_fmt = val & (I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK);
+    }
+
+    if (last_fmt != fmt)
+    return true;
 
-	return false;
+    return false;
 }
 
 static int rockchip_i2s_tdm_params_trcm(struct snd_pcm_substream *substream,
-					struct snd_pcm_hw_params *params,
-					struct snd_soc_dai *dai,
-					unsigned int div_bclk,
-					unsigned int div_lrck,
-					unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	struct snd_soc_component *comp = i2s_tdm->pcm_comp;
-	unsigned long flags;
-
-	/* Prepare params changes for trcm dma guard resume */
-	if (comp && comp->driver->hw_params)
-		comp->driver->hw_params(comp, substream, params);
-
-	spin_lock_irqsave(&i2s_tdm->lock, flags);
-	if (i2s_tdm->refcount)
-		rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-			   I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
-			   I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
-			   I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	else
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-
-	if (i2s_tdm->refcount)
-		rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
-	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
+        struct snd_soc_dai *dai,
+        unsigned int div_bclk,
+        unsigned int div_lrck,
+        unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned long flags;
+
+    spin_lock_irqsave(&i2s_tdm->lock, flags);
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_pause(substream, i2s_tdm);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+           I2S_CLKDIV_TXM_MASK | I2S_CLKDIV_RXM_MASK,
+           I2S_CLKDIV_TXM(div_bclk) | I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TSD_MASK | I2S_CKR_RSD_MASK,
+           I2S_CKR_TSD(div_lrck) | I2S_CKR_RSD(div_lrck));
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    else
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+
+    if (atomic_read(&i2s_tdm->refcount))
+    rockchip_i2s_tdm_trcm_resume(substream, i2s_tdm);
+    spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params(struct snd_pcm_substream *substream,
-				   struct snd_soc_dai *dai,
-				   unsigned int div_bclk,
-				   unsigned int div_lrck,
-				   unsigned int fmt)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	int stream = substream->stream;
-
-	if (is_stream_active(i2s_tdm, stream))
-		rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_TXM_MASK,
-				   I2S_CLKDIV_TXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_TSD_MASK,
-				   I2S_CKR_TSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
-				   fmt);
-	} else {
-		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-				   I2S_CLKDIV_RXM_MASK,
-				   I2S_CLKDIV_RXM(div_bclk));
-		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-				   I2S_CKR_RSD_MASK,
-				   I2S_CKR_RSD(div_lrck));
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
-				   fmt);
-	}
-
-	/*
-	 * Bring back CLK ASAP after cfg changed to make SINK devices active
-	 * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
-	 * sound issue. at the moment, it's 8K@60Hz display situation.
-	 */
-	if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
-	    (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
-	    (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
-		rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	}
+       struct snd_soc_dai *dai,
+       unsigned int div_bclk,
+       unsigned int div_lrck,
+       unsigned int fmt)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int stream = substream->stream;
+
+    if (is_stream_active(i2s_tdm, stream))
+    rockchip_i2s_tdm_xfer_stop(i2s_tdm, stream, true);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_TSD_MASK,
+       I2S_CKR_TSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
+       fmt);
+    } else {
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK,
+       I2S_CKR_RSD(div_lrck));
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_VDW_MASK | I2S_RXCR_CSR_MASK,
+       fmt);
+    }
+
+    /*
+     * Bring back CLK ASAP after cfg changed to make SINK devices active
+     * on HDMI-PATH-ALWAYS-ON situation, this workaround for some TVs no
+     * sound issue. at the moment, it's 8K@60Hz display situation.
+     */
+    if ((i2s_tdm->quirks & QUIRK_HDMI_PATH) &&
+        (i2s_tdm->quirks & QUIRK_ALWAYS_ON) &&
+        (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
+    rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    }
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_params_channels(struct snd_pcm_substream *substream,
-					    struct snd_pcm_hw_params *params,
-					    struct snd_soc_dai *dai)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-
-	return rockchip_i2s_tdm_parse_channels(i2s_tdm, substream->stream,
-					       params_channels(params));
-}
-
-static void rockchip_i2s_tdm_get_performance(struct snd_pcm_substream *substream,
-					     struct snd_pcm_hw_params *params,
-					     struct snd_soc_dai *dai,
-					     unsigned int csr)
+            struct snd_pcm_hw_params *params,
+            struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	unsigned int tdl;
-	int fifo;
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    unsigned int reg_fmt, fmt;
+    int ret = 0;
+    snd_pcm_format_t format = params_format(params);
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    reg_fmt = I2S_TXCR;
+    else
+    reg_fmt = I2S_RXCR;
+    /* Special handling for DSD formats - force 4-channel configuration for stereo DSD */
+    if (is_dsd(format)) {
+        dev_info(i2s_tdm->dev, "DSD channel config: FORCING 4-channel setup for stereo DSD\n");
+        /* Force 4-channel mode for DSD stereo */
+        regmap_update_bits(i2s_tdm->regmap, reg_fmt, I2S_TXCR_CSR_MASK, I2S_CHN_4);
+        return I2S_CHN_4; /* DSD requires 4 channels for stereo */
+    }
+    regmap_read(i2s_tdm->regmap, reg_fmt, &fmt);
+    fmt &= I2S_TXCR_TFS_MASK;
+
+    if (fmt == I2S_TXCR_TFS_TDM_I2S && !i2s_tdm->tdm_fsync_half_frame) {
+    switch (params_channels(params)) {
+    case 16:
+        ret = I2S_CHN_8;
+        break;
+    case 12:
+        ret = I2S_CHN_6;
+        break;
+    case 8:
+        ret = I2S_CHN_4;
+        break;
+    case 4:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    } else {
+    switch (params_channels(params)) {
+    case 8:
+        ret = I2S_CHN_8;
+        break;
+    case 6:
+        ret = I2S_CHN_6;
+        break;
+    case 4:
+        ret = I2S_CHN_4;
+        break;
+    case 2:
+        ret = I2S_CHN_2;
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+    }
 
-	regmap_read(i2s_tdm->regmap, I2S_DMACR, &tdl);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		fifo = I2S_DMACR_TDL_V(tdl) * I2S_TXCR_CSR_V(csr);
-	else
-		fifo = I2S_DMACR_RDL_V(tdl) * I2S_RXCR_CSR_V(csr);
-
-	rockchip_utils_get_performance(substream, params, dai, fifo);
+    return ret;
 }
 
 static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
-				      struct snd_pcm_hw_params *params,
-				      struct snd_soc_dai *dai)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-	struct snd_dmaengine_dai_dma_data *dma_data;
-	struct clk *mclk;
-	int ret = 0;
-	unsigned int val = 0;
-	unsigned int mclk_rate, bclk_rate, lrck_rate, div_bclk = 4, div_lrck = 64;
-
-	if (!rockchip_i2s_tdm_stream_valid(substream, dai))
-		return 0;
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (i2s_tdm->is_tdm_multi_lanes)
-		rockchip_i2s_tdm_multi_lanes_set_clk(substream, params, dai);
-#endif
-	dma_data = snd_soc_dai_get_dma_data(dai, substream);
-	dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
-
-	if (i2s_tdm->mclk_calibrate)
-		rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
-						params_rate(params));
-
-	ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
-	if (ret)
-		return ret;
-
-	mclk_rate = clk_get_rate(mclk);
-	lrck_rate = params_rate(params) * i2s_tdm->lrck_ratio;
-	bclk_rate = i2s_tdm->frame_width * lrck_rate;
-	if (!bclk_rate) {
-		return -EINVAL;
-	}
-	div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
-	div_lrck = bclk_rate / lrck_rate;
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S8:
-		val |= I2S_TXCR_VDW(8);
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		val |= I2S_TXCR_VDW(16);
-		break;
-	case SNDRV_PCM_FORMAT_S20_3LE:
-		val |= I2S_TXCR_VDW(20);
-		break;
-	case SNDRV_PCM_FORMAT_S24_LE:
-		val |= I2S_TXCR_VDW(24);
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-	case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
-		val |= I2S_TXCR_VDW(32);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
-	if (ret < 0)
-		return ret;
-
-	rockchip_i2s_tdm_get_performance(substream, params, dai, ret);
-
-	val |= ret;
-	if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
-		return 0;
-
-	if (i2s_tdm->clk_trcm)
-		rockchip_i2s_tdm_params_trcm(substream, params, dai, div_bclk, div_lrck, val);
-	else
-		rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
-
-	return rockchip_i2s_io_multiplex(substream, dai);
-}
-static int rockchip_i2s_tdm_hw_free(struct snd_pcm_substream *substream,
-				    struct snd_soc_dai *dai)
+          struct snd_pcm_hw_params *params,
+          struct snd_soc_dai *dai)
 {
-	if (!rockchip_i2s_tdm_stream_valid(substream, dai))
-		return 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    struct snd_dmaengine_dai_dma_data *dma_data;
+    struct clk *mclk;
+    int ret = 0;
+    unsigned int val = 0;
+    unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
+
+    dma_data = snd_soc_dai_get_dma_data(dai, substream);
+    dma_data->maxburst = MAXBURST_PER_FIFO * params_channels(params) / 2;
+
+
+    /* Note: Mute is now handled in trigger for proper timing */
+    
+
+    if (i2s_tdm->is_master_mode) {
+        if (i2s_tdm->mclk_calibrate)
+            rockchip_i2s_tdm_calibrate_mclk(i2s_tdm, substream,
+                            params_rate(params));
+if( i2s_tdm->mclk_external ){
+            mclk = i2s_tdm->mclk_tx;
+            if( i2s_tdm->mclk_ext_mux ) {
+                /* Consider MCLK multiplier for external PLL - match kernel 5.10 behavior */
+                if( params_rate(params) % 44100 ) {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
+                    /* 48kHz family: 24.576MHz (512x) or 49.152MHz (1024x) */
+                    if (i2s_tdm->mclk_multiplier == 1024) {
+                        clk_set_rate(i2s_tdm->mclk_tx, 49152000);
+                    } else {
+                        clk_set_rate(i2s_tdm->mclk_tx, 24576000);
+                    }
+                }
+                else {
+                    clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
+                    /* 44.1kHz family: 22.579MHz (512x) or 45.158MHz (1024x) */
+                    if (i2s_tdm->mclk_multiplier == 1024) {
+                        clk_set_rate(i2s_tdm->mclk_tx, 45158400);
+                    } else {
+                        clk_set_rate(i2s_tdm->mclk_tx, 22579200);
+                    }
+                }
+                dev_info(i2s_tdm->dev, "External PLL: MCLK set to %lu Hz (multiplier %dx)\n",
+                         clk_get_rate(i2s_tdm->mclk_tx), i2s_tdm->mclk_multiplier);
+            }
+        }
+        else {
+            ret = rockchip_i2s_tdm_set_mclk(i2s_tdm, substream, &mclk);
+            if (ret)
+                goto err;
+        }
+
+        mclk_rate = clk_get_rate(mclk);
+        
+        /* Special handling for DSD formats */
+        if (is_dsd(params_format(params))) {
+            bclk_rate = calculate_dsd_bclk(params_format(params), params_rate(params));
+            /* DSD always uses 22.579 MHz MCLK - force it if different */
+            if (mclk_rate != 22579200) {
+                dev_info(i2s_tdm->dev, "DSD: MCLK rate %u Hz, expected 22579200 Hz\n", mclk_rate);
+            }
+            dev_info(i2s_tdm->dev, "DSD mode: BCLK=%u Hz, MCLK=%u Hz\n", bclk_rate, mclk_rate);
+        } else {
+            bclk_rate = i2s_tdm->bclk_fs * params_rate(params);
+        }
+        
+        if (!bclk_rate) {
+            ret = -EINVAL;
+            goto err;
+        }
+
+        div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
+        div_lrck = bclk_rate / params_rate(params);
+        dev_info(i2s_tdm->dev, "Clock dividers: mclk_rate=%u, bclk_rate=%u, div_bclk=%u, div_lrck=%u\n",
+                 mclk_rate, bclk_rate, div_bclk, div_lrck);
+    }
+
+    /* Static 1MB buffers are set in rockchip_i2s_tdm_pcm_hardware structure */
+
+    switch (params_format(params)) {
+    case SNDRV_PCM_FORMAT_S8:
+        val |= I2S_TXCR_VDW(8);
+        /* Disable DSD-on signal for PCM formats */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, false);
+        break;
+    case SNDRV_PCM_FORMAT_S16_LE:
+        val |= I2S_TXCR_VDW(16);
+        /* Disable DSD-on signal for PCM formats */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, false);
+        break;
+    case SNDRV_PCM_FORMAT_S20_3LE:
+        val |= I2S_TXCR_VDW(20);
+        /* Disable DSD-on signal for PCM formats */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, false);
+        break;
+    case SNDRV_PCM_FORMAT_S24_LE:
+        val |= I2S_TXCR_VDW(24);
+        /* Disable DSD-on signal for PCM formats */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, false);
+        break;
+    case SNDRV_PCM_FORMAT_S32_LE:
+    case SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:
+        val |= I2S_TXCR_VDW(32);
+        /* Disable DSD-on signal for PCM formats */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, false);
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U8:
+        val |= I2S_TXCR_VDW(8); /* DSD_U8: return standard 8-bit container */
+
+        /* FORCE disable mmap for DSD_U8 - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD U8: mmap DISABLED, copy_user FORCED\n");
+
+        /* Activate DSD-on signal */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, true);
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U16_LE:
+        val |= I2S_TXCR_VDW(16);
+
+        /* FORCE disable mmap for DSD - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD U16: mmap DISABLED, copy_user FORCED\n");
+
+        /* Activate DSD-on signal */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, true);
+        break;
+    case SNDRV_PCM_FORMAT_DSD_U32_LE:
+    case SNDRV_PCM_FORMAT_DSD_U32_BE:
+        val |= I2S_TXCR_VDW(16); /* DSD: only 16 bits of data in 32-bit container */
+
+        /* FORCE disable mmap for DSD - force use of copy_user */
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP;
+        substream->runtime->hw.info &= ~SNDRV_PCM_INFO_MMAP_VALID;
+        dev_info(i2s_tdm->dev, "DSD: mmap DISABLED, copy_user FORCED\n");
+
+        /* Activate DSD-on signal */
+        rockchip_i2s_tdm_handle_dsd_switch(i2s_tdm, true);
+        break;
+    default:
+        ret = -EINVAL;
+        goto err;
+    }
+
+    ret = rockchip_i2s_tdm_params_channels(substream, params, dai);
+    if (ret < 0)
+        goto err;
+
+    val |= ret;
+
+    /* Apply PCM channel swap if enabled and not in DSD mode */
+    if (!i2s_tdm->dsd_mode_active) {
+        unsigned int mask, ckr_val;
+
+        mask = I2S_CKR_TLP_MASK | I2S_CKR_RLP_MASK;
+        regmap_read(i2s_tdm->regmap, I2S_CKR, &ckr_val);
+
+        ckr_val &= ~mask;
+        if (i2s_tdm->pcm_channel_swap) {
+            ckr_val |= I2S_CKR_TLP_INVERTED | I2S_CKR_RLP_INVERTED;
+        } else {
+            ckr_val |= I2S_CKR_TLP_NORMAL | I2S_CKR_RLP_NORMAL;
+        }
+        regmap_update_bits(i2s_tdm->regmap, I2S_CKR, mask, ckr_val);
+    }
+
+    if (!is_params_dirty(substream, dai, div_bclk, div_lrck, val))
+        return 0;
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_params_trcm(substream, dai, div_bclk, div_lrck, val);
+    else
+        rockchip_i2s_tdm_params(substream, dai, div_bclk, div_lrck, val);
 
-	rockchip_utils_put_performance(substream, dai);
+    ret = rockchip_i2s_io_multiplex(substream, dai);
 
-	return 0;
+err:
+    return ret;
 }
 
+/* Updated trigger function */
 static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
-				    int cmd, struct snd_soc_dai *dai)
+        int cmd, struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
-
-	if (!rockchip_i2s_tdm_stream_valid(substream, dai))
-		return 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+    int ret = 0;
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
-		break;
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
-		break;
-	default:
-		return -EINVAL;
-	}
+    switch (cmd) {
+    case SNDRV_PCM_TRIGGER_START:
+    /* Reset pause state on start */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        i2s_tdm->playback_paused = false;
+        
+        /* Ensure auto_mute is active for this playback session */
+        if (!i2s_tdm->user_mute_priority) {
+            i2s_tdm->auto_mute_active = true;
+        }
+        
+        /* Start stream immediately - mute is already ON by default */
+        rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+        
+        /* Schedule unmute after postmute delay */
+        if (!i2s_tdm->user_mute_priority && i2s_tdm->postmute_delay_ms > 0) {
+            schedule_delayed_work(&i2s_tdm->mute_post_work, 
+                                msecs_to_jiffies(i2s_tdm->postmute_delay_ms));
+            dev_info(i2s_tdm->dev, "TRIGGER START: Stream started, unmute in %dms\n", 
+                     i2s_tdm->postmute_delay_ms);
+        }
+    } else {
+        i2s_tdm->capture_paused = false;
+        rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    }
+    break;
+    case SNDRV_PCM_TRIGGER_RESUME:
+    /* Reset pause state on system resume */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->playback_paused = false;
+    else
+        i2s_tdm->capture_paused = false;
+    rockchip_i2s_tdm_start(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    /* Resume after pause */
+    rockchip_i2s_tdm_resume(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_SUSPEND:
+    case SNDRV_PCM_TRIGGER_STOP:
+    /* Reset pause state on stop */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        i2s_tdm->playback_paused = false;
+        
+        /* Cancel any pending unmute work */
+        cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
+        
+        /* Enable mute when playback stops (no useful signal) */
+        mutex_lock(&i2s_tdm->mute_lock);
+        if (!i2s_tdm->user_mute_priority && !i2s_tdm->format_change_mute) {
+            if (i2s_tdm->mute_gpio) {
+                gpiod_set_value(i2s_tdm->mute_gpio, 1);
+                if (i2s_tdm->mute_inv_gpio)
+                    gpiod_set_value(i2s_tdm->mute_inv_gpio, 0);
+            }
+            i2s_tdm->auto_mute_active = true;
+            rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+            dev_info(i2s_tdm->dev, "TRIGGER STOP: Mute enabled (no signal)\n");
+        }
+        mutex_unlock(&i2s_tdm->mute_lock);
+    } else {
+        i2s_tdm->capture_paused = false;
+    }
+    rockchip_i2s_tdm_stop(i2s_tdm, substream->stream);
+    break;
+    case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+    /* Stream suspension */
+    rockchip_i2s_tdm_pause(i2s_tdm, substream->stream);
+    break;
+    default:
+    ret = -EINVAL;
+    break;
+    }
 
-	return 0;
+    return ret;
 }
 
 static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
-				       unsigned int freq, int dir)
+           unsigned int freq, int dir)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+    unsigned int fixed_freq;
 
-	/* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
-	if (i2s_tdm->clk_trcm) {
-		i2s_tdm->mclk_tx_freq = freq;
-		i2s_tdm->mclk_rx_freq = freq;
-	} else {
-		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-			i2s_tdm->mclk_tx_freq = freq;
-		else
-			i2s_tdm->mclk_rx_freq = freq;
-	}
+    /* Fix MCLK to standard frequencies for each domain with multiplier support */
+    if (freq % 44100 == 0) {
+        /* 44.1 kHz family - use 22579200 Hz (512x) or 45158400 Hz (1024x) */
+        fixed_freq = (i2s_tdm->mclk_multiplier == 1024) ? 45158400 : 22579200;
+    } else {
+        /* 48 kHz family - use 24576000 Hz (512x) or 49152000 Hz (1024x) */
+        fixed_freq = (i2s_tdm->mclk_multiplier == 1024) ? 49152000 : 24576000;
+    }
+
+    /* Put set mclk rate into rockchip_i2s_tdm_set_mclk() */
+    if (i2s_tdm->clk_trcm) {
+    i2s_tdm->mclk_tx_freq = fixed_freq;
+    i2s_tdm->mclk_rx_freq = fixed_freq;
+    } else {
+    if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+        i2s_tdm->mclk_tx_freq = fixed_freq;
+    else
+        i2s_tdm->mclk_rx_freq = fixed_freq;
+    }
 
-	dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d\n",
-		stream ? "rx" : "tx", freq);
+    dev_dbg(i2s_tdm->dev, "The target mclk_%s freq is: %d (fixed from %d)\n",
+    stream ? "rx" : "tx", fixed_freq, freq);
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_info(struct snd_kcontrol *kcontrol,
-						  struct snd_ctl_elem_info *uinfo)
+          struct snd_ctl_elem_info *uinfo)
 {
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = CLK_PPM_MIN;
-	uinfo->value.integer.max = CLK_PPM_MAX;
-	uinfo->value.integer.step = 1;
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = CLK_PPM_MIN;
+    uinfo->value.integer.max = CLK_PPM_MAX;
+    uinfo->value.integer.step = 1;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_get(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
+    ucontrol->value.integer.value[0] = i2s_tdm->clk_ppm;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_clk_compensation_put(struct snd_kcontrol *kcontrol,
-						 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	int ret = 0, ppm = 0;
-	int changed = 0;
-	unsigned long old_rate;
-
-	if (ucontrol->value.integer.value[0] < CLK_PPM_MIN ||
-	    ucontrol->value.integer.value[0] > CLK_PPM_MAX)
-		return -EINVAL;
-
-	ppm = ucontrol->value.integer.value[0];
-
-	old_rate = clk_get_rate(i2s_tdm->mclk_root0);
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
-					    i2s_tdm->mclk_root0_freq, ppm);
-	if (ret)
-		return ret;
-	if (old_rate != clk_get_rate(i2s_tdm->mclk_root0))
-		changed = 1;
-
-	if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
-		return changed;
-
-	old_rate = clk_get_rate(i2s_tdm->mclk_root1);
-	ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
-					    i2s_tdm->mclk_root1_freq, ppm);
-	if (ret)
-		return ret;
-	if (old_rate != clk_get_rate(i2s_tdm->mclk_root1))
-		changed = 1;
-
-	return changed;
-}
-
-static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
-	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
-	.name = "PCM Clk Compensation In PPM",
-	.info = rockchip_i2s_tdm_clk_compensation_info,
-	.get = rockchip_i2s_tdm_clk_compensation_get,
-	.put = rockchip_i2s_tdm_clk_compensation_put,
-};
-
-/* loopback mode select */
-enum {
-	LOOPBACK_MODE_DIS = 0,
-	LOOPBACK_MODE_1,
-	LOOPBACK_MODE_2,
-	LOOPBACK_MODE_2_SWAP,
-};
-
-static const char *const loopback_text[] = {
-	"Disabled",
-	"Mode1",
-	"Mode2",
-	"Mode2 Swap",
-};
-
-static SOC_ENUM_SINGLE_EXT_DECL(loopback_mode, loopback_text);
-
-static int rockchip_i2s_tdm_loopback_get(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
+         struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int reg = 0, mode = 0;
-
-	pm_runtime_get_sync(component->dev);
-	regmap_read(i2s_tdm->regmap, I2S_XFER, &reg);
-	pm_runtime_put(component->dev);
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret = 0, ppm = 0;
 
-	switch (reg & I2S_XFER_LP_MODE_MASK) {
-	case I2S_XFER_LP_MODE_2_SWAP:
-		mode = LOOPBACK_MODE_2_SWAP;
-		break;
-	case I2S_XFER_LP_MODE_2:
-		mode = LOOPBACK_MODE_2;
-		break;
-	case I2S_XFER_LP_MODE_1:
-		mode = LOOPBACK_MODE_1;
-		break;
-	default:
-		mode = LOOPBACK_MODE_DIS;
-		break;
-	}
+    if ((ucontrol->value.integer.value[0] < CLK_PPM_MIN) ||
+        (ucontrol->value.integer.value[0] > CLK_PPM_MAX))
+    return -EINVAL;
 
-	ucontrol->value.enumerated.item[0] = mode;
+    ppm = ucontrol->value.integer.value[0];
 
-	return 0;
-}
-
-static int rockchip_i2s_tdm_loopback_put(struct snd_kcontrol *kcontrol,
-					 struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-	unsigned int val = 0, mode = ucontrol->value.enumerated.item[0];
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root0,
+            i2s_tdm->mclk_root0_freq, ppm);
+    if (ret)
+    return ret;
 
-	if (mode < LOOPBACK_MODE_DIS ||
-	    mode > LOOPBACK_MODE_2_SWAP)
-		return -EINVAL;
+    if (clk_is_match(i2s_tdm->mclk_root0, i2s_tdm->mclk_root1))
+    return 0;
 
-	switch (mode) {
-	case LOOPBACK_MODE_2_SWAP:
-		val = I2S_XFER_LP_MODE_2_SWAP;
-		break;
-	case LOOPBACK_MODE_2:
-		val = I2S_XFER_LP_MODE_2;
-		break;
-	case LOOPBACK_MODE_1:
-		val = I2S_XFER_LP_MODE_1;
-		break;
-	default:
-		val = I2S_XFER_LP_MODE_DIS;
-		break;
-	}
+    ret = rockchip_i2s_tdm_clk_set_rate(i2s_tdm, i2s_tdm->mclk_root1,
+            i2s_tdm->mclk_root1_freq, ppm);
 
-	pm_runtime_get_sync(component->dev);
-	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, I2S_XFER_LP_MODE_MASK, val);
-	pm_runtime_put(component->dev);
-
-	return 0;
+    return ret;
 }
 
-static const char * const rpaths_text[] = {
-	"From SDI0", "From SDI1", "From SDI2", "From SDI3" };
-
-static const char * const tpaths_text[] = {
-	"From PATH0", "From PATH1", "From PATH2", "From PATH3" };
-
-/* TXCR */
-static SOC_ENUM_SINGLE_DECL(tpath3_enum, I2S_TXCR, 29, tpaths_text);
-static SOC_ENUM_SINGLE_DECL(tpath2_enum, I2S_TXCR, 27, tpaths_text);
-static SOC_ENUM_SINGLE_DECL(tpath1_enum, I2S_TXCR, 25, tpaths_text);
-static SOC_ENUM_SINGLE_DECL(tpath0_enum, I2S_TXCR, 23, tpaths_text);
-
-/* RXCR */
-static SOC_ENUM_SINGLE_DECL(rpath3_enum, I2S_RXCR, 23, rpaths_text);
-static SOC_ENUM_SINGLE_DECL(rpath2_enum, I2S_RXCR, 21, rpaths_text);
-static SOC_ENUM_SINGLE_DECL(rpath1_enum, I2S_RXCR, 19, rpaths_text);
-static SOC_ENUM_SINGLE_DECL(rpath0_enum, I2S_RXCR, 17, rpaths_text);
-
-static int rockchip_i2s_tdm_wait_time_info(struct snd_kcontrol *kcontrol,
-					   struct snd_ctl_elem_info *uinfo)
-{
-	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-	uinfo->count = 1;
-	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = WAIT_TIME_MS_MAX;
-	uinfo->value.integer.step = 1;
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_rd_wait_time_get(struct snd_kcontrol *kcontrol,
-					     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	ucontrol->value.integer.value[0] = i2s_tdm->wait_time[SNDRV_PCM_STREAM_CAPTURE];
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_rd_wait_time_put(struct snd_kcontrol *kcontrol,
-					     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	if (ucontrol->value.integer.value[0] > WAIT_TIME_MS_MAX)
-		return -EINVAL;
-
-	i2s_tdm->wait_time[SNDRV_PCM_STREAM_CAPTURE] = ucontrol->value.integer.value[0];
-
-	return 1;
-}
+static struct snd_kcontrol_new rockchip_i2s_tdm_compensation_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_PCM,
+    .name = "PCM Clk Compensation In PPM",
+    .info = rockchip_i2s_tdm_clk_compensation_info,
+    .get = rockchip_i2s_tdm_clk_compensation_get,
+    .put = rockchip_i2s_tdm_clk_compensation_put,
+};
 
-static int rockchip_i2s_tdm_wr_wait_time_get(struct snd_kcontrol *kcontrol,
-					     struct snd_ctl_elem_value *ucontrol)
-{
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
 
-	ucontrol->value.integer.value[0] = i2s_tdm->wait_time[SNDRV_PCM_STREAM_PLAYBACK];
+static const struct snd_kcontrol_new rockchip_i2s_tdm_snd_controls[] = {
+};
 
-	return 0;
-}
+/* Control structures defined after functions */
 
-static int rockchip_i2s_tdm_wr_wait_time_put(struct snd_kcontrol *kcontrol,
-					     struct snd_ctl_elem_value *ucontrol)
+static int rockchip_i2s_tdm_volume_info(struct snd_kcontrol *kcontrol,
+                                        struct snd_ctl_elem_info *uinfo)
 {
-	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	if (ucontrol->value.integer.value[0] > WAIT_TIME_MS_MAX)
-		return -EINVAL;
-
-	i2s_tdm->wait_time[SNDRV_PCM_STREAM_PLAYBACK] = ucontrol->value.integer.value[0];
-
-	return 1;
-}
-
-#define SAI_PCM_WAIT_TIME(xname, xhandler_get, xhandler_put)	\
-{	.iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = xname,	\
-	.info = rockchip_i2s_tdm_wait_time_info,			\
-	.get = xhandler_get, .put = xhandler_put }
-
-static const struct snd_kcontrol_new rockchip_i2s_tdm_snd_controls[] = {
-	SOC_ENUM("Receive PATH3 Source Select", rpath3_enum),
-	SOC_ENUM("Receive PATH2 Source Select", rpath2_enum),
-	SOC_ENUM("Receive PATH1 Source Select", rpath1_enum),
-	SOC_ENUM("Receive PATH0 Source Select", rpath0_enum),
-	SOC_ENUM("Transmit SDO3 Source Select", tpath3_enum),
-	SOC_ENUM("Transmit SDO2 Source Select", tpath2_enum),
-	SOC_ENUM("Transmit SDO1 Source Select", tpath1_enum),
-	SOC_ENUM("Transmit SDO0 Source Select", tpath0_enum),
-
-	SOC_ENUM_EXT("I2STDM Digital Loopback Mode", loopback_mode,
-		     rockchip_i2s_tdm_loopback_get,
-		     rockchip_i2s_tdm_loopback_put),
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	SOC_ENUM_EXT("Transmit SDOx Select", tx_lanes_enum,
-		     rockchip_i2s_tdm_tx_lanes_get, rockchip_i2s_tdm_tx_lanes_put),
-	SOC_ENUM_EXT("Receive SDIx Select", rx_lanes_enum,
-		     rockchip_i2s_tdm_rx_lanes_get, rockchip_i2s_tdm_rx_lanes_put),
-#endif
-	SAI_PCM_WAIT_TIME("PCM Read Wait Time MS",
-			  rockchip_i2s_tdm_rd_wait_time_get,
-			  rockchip_i2s_tdm_rd_wait_time_put),
-	SAI_PCM_WAIT_TIME("PCM Write Wait Time MS",
-			  rockchip_i2s_tdm_wr_wait_time_get,
-			  rockchip_i2s_tdm_wr_wait_time_put),
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 100;
+    uinfo->value.integer.step = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_volume_get(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    ucontrol->value.integer.value[0] = i2s_tdm->volume;
+    return 0;
+}
+
+/* Basic volume setting function */
+static int rockchip_i2s_tdm_volume_put(struct snd_kcontrol *kcontrol,
+                                       struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int volume = ucontrol->value.integer.value[0];
+    int old_volume = i2s_tdm->volume;
+
+    if (volume < 0 || volume > 100)
+        return -EINVAL;
+
+    if (volume == old_volume)
+        return 0;
+
+    i2s_tdm->volume = volume;
+    
+    dev_info(i2s_tdm->dev, "Volume changed: %d%% -> %d%%\n",
+             old_volume, volume);
+    
+    return 1;
+}
+
+static int rockchip_i2s_tdm_mute_info(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_info *uinfo)
+{
+    uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+    uinfo->count = 1;
+    uinfo->value.integer.min = 0;
+    uinfo->value.integer.max = 1;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_get(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+
+    /* Invert value for player: mute=false -> return 1 (unmute) */
+    ucontrol->value.integer.value[0] = !i2s_tdm->mute;
+    return 0;
+}
+
+static int rockchip_i2s_tdm_mute_put(struct snd_kcontrol *kcontrol,
+                                     struct snd_ctl_elem_value *ucontrol)
+{
+    struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    bool mute_request = ucontrol->value.integer.value[0];
+    
+    /* Invert logic: player passes 1=unmute, 0=mute */
+    bool mute = !mute_request;
+
+    if (i2s_tdm->mute == mute)
+        return 0;
+
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    i2s_tdm->mute = mute;
+
+    if (mute) {
+        /* User enabled mute - set priority */
+        i2s_tdm->user_mute_priority = true;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Enable mute instantly */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+        dev_info(i2s_tdm->dev, "User mute ON: mute_gpio=%p inv_gpio=%p\n", 
+                 i2s_tdm->mute_gpio, i2s_tdm->mute_inv_gpio);
+        
+    } else {
+        /* User disabled mute - reset priority but keep auto_mute if no signal */
+        i2s_tdm->user_mute_priority = false;
+        
+        /* Check if stream is running */
+        bool stream_running = false;
+        if (i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK]) {
+            struct snd_pcm_substream *substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
+            struct snd_pcm_runtime *runtime = substream->runtime;
+            if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING) {
+                stream_running = true;
+            }
+        }
+        
+        /* Only unmute if stream is running */
+        if (stream_running) {
+            i2s_tdm->auto_mute_active = false;
+            cancel_delayed_work(&i2s_tdm->mute_post_work);
+            rockchip_i2s_tdm_apply_mute(i2s_tdm, false);
+            dev_info(i2s_tdm->dev, "User unmute: stream running, mute OFF\n");
+        } else {
+            /* Keep auto mute active - no signal yet */
+            dev_info(i2s_tdm->dev, "User unmute: no stream, keeping mute ON\n");
+        }
+    }
+
+    mutex_unlock(&i2s_tdm->mute_lock);
+    
+    /* Notify ALSA about mute state change for synchronization with alsamixer */
+    if (i2s_tdm->mute_kcontrol && i2s_tdm->dai && i2s_tdm->dai->component) {
+        snd_ctl_notify(i2s_tdm->dai->component->card->snd_card, SNDRV_CTL_EVENT_MASK_VALUE, &i2s_tdm->mute_kcontrol->id);
+    }
+    
+    return 1; /* Return 1 to notify ALSA of change */
+}
+
+/* Automatic mute during switching */
+static void rockchip_i2s_tdm_apply_mute(struct rk_i2s_tdm_dev *i2s_tdm, bool enable)
+{
+    if (enable) {
+        /* Enable mute INSTANTLY */
+        if (i2s_tdm->mute_gpio)
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+        if (i2s_tdm->mute_inv_gpio) {
+            gpiod_set_value(i2s_tdm->mute_inv_gpio, 0);
+            dev_dbg(i2s_tdm->dev, "Set inverted GPIO to 0 (mute ON)\n");
+        }
+        
+        /* Software mute through volume = 0% for DACs without GPIO mute */
+        /* Clear active DMA buffers immediately for instant mute effect */
+        if (i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK]) {
+            struct snd_pcm_substream *substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
+            struct snd_pcm_runtime *runtime = substream->runtime;
+            
+            if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING && runtime->dma_area) {
+                /* Clear current DMA buffers for immediate silence */
+                memset(runtime->dma_area, 0, runtime->dma_bytes);
+                dev_dbg(i2s_tdm->dev, "DMA buffers cleared for immediate mute\n");
+            }
+        }
+        
+        
+        /* DO NOT disable DMA - this leads to pause instead of mute */
+        /* DMA continues to work, but sound is muted through GPIO + software */
+        
+    } else {
+        /* Disable mute - called only from scheduled work after trigger start */
+        if (i2s_tdm->mute_gpio) {
+            gpiod_set_value(i2s_tdm->mute_gpio, 0);
+            if (i2s_tdm->mute_inv_gpio) {
+                gpiod_set_value(i2s_tdm->mute_inv_gpio, 1);
+                dev_dbg(i2s_tdm->dev, "Set inverted GPIO to 1 (mute OFF)\n");
+            }
+        }
+    }
+}
+
+/* Function for post-mute work thread (disable mute after delay) */
+static void rockchip_i2s_tdm_mute_post_work(struct work_struct *work)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = container_of(work, struct rk_i2s_tdm_dev, mute_post_work.work);
+    
+    /* Check that device is still active */
+    if (!i2s_tdm->dev || !device_is_registered(i2s_tdm->dev)) {
+        dev_warn(i2s_tdm->dev, "Device unregistered during post-mute work\n");
+        return;
+    }
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    /* Do NOT unmute if format change mute is active */
+    if (i2s_tdm->format_change_mute) {
+        dev_info(i2s_tdm->dev, "POST-MUTE: Skipping unmute - format change in progress\n");
+        mutex_unlock(&i2s_tdm->mute_lock);
+        return;
+    }
+    
+    /* Unmute if auto_mute is active and no user mute priority */
+    /* This work is only scheduled from TRIGGER_START, so stream is running */
+    dev_info(i2s_tdm->dev, "POST-MUTE: auto_mute=%d user_priority=%d\n", 
+             i2s_tdm->auto_mute_active, i2s_tdm->user_mute_priority);
+    
+    if (i2s_tdm->auto_mute_active && !i2s_tdm->user_mute_priority) {
+        i2s_tdm->auto_mute_active = false;
+        i2s_tdm->mute = false;
+        if (i2s_tdm->mute_gpio) {
+            gpiod_set_value(i2s_tdm->mute_gpio, 0);
+            if (i2s_tdm->mute_inv_gpio)
+                gpiod_set_value(i2s_tdm->mute_inv_gpio, 1);
+        }
+        dev_info(i2s_tdm->dev, "POST-MUTE: Unmuted after %dms\n", i2s_tdm->postmute_delay_ms);
+        
+        /* Notify ALSA control about mute state change */
+        if (i2s_tdm->mute_kcontrol && i2s_tdm->dai && i2s_tdm->dai->component) {
+            snd_ctl_notify(i2s_tdm->dai->component->card->snd_card, 
+                          SNDRV_CTL_EVENT_MASK_VALUE, 
+                          &i2s_tdm->mute_kcontrol->id);
+        }
+    } else {
+        dev_info(i2s_tdm->dev, "POST-MUTE: Unmute BLOCKED\n");
+    }
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+}
+
+/* MCLK multiplier sysfs interface */
+static ssize_t mclk_multiplier_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->mclk_multiplier);
+}
+
+static ssize_t mclk_multiplier_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int multiplier;
+    
+    if (sscanf(buf, "%d", &multiplier) != 1)
+        return -EINVAL;
+    
+    if (multiplier != 512 && multiplier != 1024) {
+        dev_err(dev, "Invalid MCLK multiplier: %d. Must be 512 or 1024.\n", multiplier);
+        return -EINVAL;
+    }
+    
+    i2s_tdm->mclk_multiplier = multiplier;
+    dev_info(dev, "MCLK multiplier set to %dx\n", multiplier);
+    
+    return count;
+}
+
+static DEVICE_ATTR(mclk_multiplier, 0644, mclk_multiplier_show, mclk_multiplier_store);
+
+/* DSD channel swap sysfs interface */
+
+static ssize_t dsd_sample_swap_show(struct device *dev,
+                                   struct device_attribute *attr,
+                                   char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->dsd_sample_swap ? 1 : 0);
+}
+
+static ssize_t dsd_sample_swap_store(struct device *dev,
+                                    struct device_attribute *attr,
+                                    const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    i2s_tdm->dsd_sample_swap = enable ? true : false;
+    dev_info(dev, "DSD Sample Swap to eliminate purple noise %s\n", 
+             enable ? "ENABLED" : "DISABLED");
+    
+    return count;
+}
+
+static DEVICE_ATTR(dsd_sample_swap, 0644, dsd_sample_swap_show, dsd_sample_swap_store);
+
+static ssize_t pcm_channel_swap_show(struct device *dev,
+                                    struct device_attribute *attr,
+                                    char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->pcm_channel_swap ? 1 : 0);
+}
+
+static ssize_t pcm_channel_swap_store(struct device *dev,
+                                     struct device_attribute *attr,
+                                     const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    /* Accept only 0 or 1 */
+    if (enable != 0 && enable != 1)
+        return -EINVAL;
+    
+    i2s_tdm->pcm_channel_swap = (enable == 1);
+    
+    dev_info(dev, "PCM Channel Swap (LRCK inversion) %s\n", 
+             enable ? "ENABLED" : "DISABLED");
+    
+    /* Changes will apply on next playback */
+    
+    return count;
+}
+
+static DEVICE_ATTR(pcm_channel_swap, 0644, pcm_channel_swap_show, pcm_channel_swap_store);
+
+static ssize_t dsd_physical_swap_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->dsd_physical_swap ? 1 : 0);
+}
+
+static ssize_t dsd_physical_swap_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    i2s_tdm->dsd_physical_swap = enable ? true : false;
+    dev_info(dev, "DSD Physical Channel Swap %s\n", 
+             enable ? "enabled" : "disabled");
+    
+    /* FIX: Apply routing changes ONLY for current DSD mode */
+    if (i2s_tdm->dsd_mode_active) {
+        /* If DSD mode is active - apply swap immediately */
+        rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        dev_info(dev, "DSD Physical Channel Swap applied immediately (DSD mode active)\n");
+    } else {
+        /* If PCM mode - only save setting, will be applied when switching to DSD */
+        dev_info(dev, "DSD Physical Channel Swap setting saved (will apply in DSD mode)\n");
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(dsd_physical_swap, 0644, dsd_physical_swap_show, dsd_physical_swap_store);
+
+/* Frequency domain GPIO polarity control sysfs interface */
+static ssize_t freq_domain_invert_show(struct device *dev,
+                                       struct device_attribute *attr,
+                                       char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->freq_domain_invert ? 1 : 0);
+}
+
+static ssize_t freq_domain_invert_store(struct device *dev,
+                                        struct device_attribute *attr,
+                                        const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int value;
+    
+    if (sscanf(buf, "%d", &value) != 1)
+        return -EINVAL;
+    
+    if (value != 0 && value != 1)
+        return -EINVAL;
+    
+    i2s_tdm->freq_domain_invert = (value == 1);
+    dev_dbg(dev, "Frequency domain GPIO polarity inversion %s\n", 
+             i2s_tdm->freq_domain_invert ? "ENABLED" : "DISABLED");
+    
+    return count;
+}
+
+static DEVICE_ATTR(freq_domain_invert, 0644, freq_domain_invert_show, freq_domain_invert_store);
+
+/* Manual DSD mode control sysfs interface */
+static ssize_t dsd_mode_manual_show(struct device *dev,
+                                    struct device_attribute *attr,
+                                    char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->dsd_mode_active ? 1 : 0);
+}
+
+static ssize_t dsd_mode_manual_store(struct device *dev,
+                                     struct device_attribute *attr,
+                                     const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int mode;
+    
+    if (sscanf(buf, "%d", &mode) != 1)
+        return -EINVAL;
+    
+    if (mode != 0 && mode != 1)
+        return -EINVAL;
+    
+    if (!i2s_tdm->dsd_on_gpio)
+        return -ENODEV;
+    
+    if (mode == 0 && i2s_tdm->dsd_mode_active) {
+        dev_info(dev, "Manual switch: DSD -> PCM\n");
+        /* Enable mute before switch */
+        if (i2s_tdm->mute_gpio) {
+            cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
+            i2s_tdm->format_change_mute = true;
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+            if (i2s_tdm->mute_inv_gpio)
+                gpiod_set_value(i2s_tdm->mute_inv_gpio, 0);
+            msleep(50);
+        }
+        i2s_tdm->dsd_mode_active = false;
+        gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+        dev_info(dev, "DSD-on GPIO deactivated (PCM mode)\n");
+        rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        if (i2s_tdm->mute_gpio) {
+            msleep(500);
+            i2s_tdm->format_change_mute = false;
+        }
+    } else if (mode == 1 && !i2s_tdm->dsd_mode_active) {
+        dev_info(dev, "Manual switch: PCM -> DSD\n");
+        /* Enable mute before switch */
+        if (i2s_tdm->mute_gpio) {
+            cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
+            i2s_tdm->format_change_mute = true;
+            gpiod_set_value(i2s_tdm->mute_gpio, 1);
+            if (i2s_tdm->mute_inv_gpio)
+                gpiod_set_value(i2s_tdm->mute_inv_gpio, 0);
+            msleep(50);
+        }
+        i2s_tdm->dsd_mode_active = true;
+        gpiod_set_value(i2s_tdm->dsd_on_gpio, 1);
+        dev_info(dev, "DSD-on GPIO activated (DSD mode)\n");
+        rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+        if (i2s_tdm->mute_gpio) {
+            msleep(500);
+            i2s_tdm->format_change_mute = false;
+        }
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(dsd_mode_manual, 0644, dsd_mode_manual_show, dsd_mode_manual_store);
+
+/* Postmute delay sysfs interface */
+static ssize_t postmute_delay_ms_show(struct device *dev,
+                                     struct device_attribute *attr,
+                                     char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", i2s_tdm->postmute_delay_ms);
+}
+
+static ssize_t postmute_delay_ms_store(struct device *dev,
+                                      struct device_attribute *attr,
+                                      const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    unsigned int delay;
+
+    if (kstrtouint(buf, 10, &delay) || delay > 2000)
+        return -EINVAL;
+
+    i2s_tdm->postmute_delay_ms = delay;
+    dev_info(i2s_tdm->dev, "Postmute delay set to %u ms", delay);
+
+    return count;
+}
+
+static DEVICE_ATTR(postmute_delay_ms, 0644, postmute_delay_ms_show, postmute_delay_ms_store);
+
+/* Mute control sysfs interface */
+static ssize_t mute_show(struct device *dev,
+                        struct device_attribute *attr,
+                        char *buf)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    return sprintf(buf, "%d\n", i2s_tdm->mute ? 1 : 0);
+}
+
+static ssize_t mute_store(struct device *dev,
+                         struct device_attribute *attr,
+                         const char *buf, size_t count)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int enable;
+    
+    if (sscanf(buf, "%d", &enable) != 1)
+        return -EINVAL;
+    
+    /* Accept only 0 or 1 */
+    if (enable != 0 && enable != 1)
+        return -EINVAL;
+    
+    mutex_lock(&i2s_tdm->mute_lock);
+    
+    if (enable && !i2s_tdm->mute) {
+        /* Enable mute */
+        i2s_tdm->mute = true;
+        i2s_tdm->user_mute_priority = true;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Enable mute instantly */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, true);
+        
+    } else if (!enable && i2s_tdm->mute) {
+        /* Disable mute */
+        i2s_tdm->mute = false;
+        i2s_tdm->user_mute_priority = false;
+        i2s_tdm->auto_mute_active = false;
+        
+        /* Cancel any automatic timers */
+        cancel_delayed_work(&i2s_tdm->mute_post_work);
+        
+        /* Disable mute */
+        rockchip_i2s_tdm_apply_mute(i2s_tdm, false);
+    }
+    
+    mutex_unlock(&i2s_tdm->mute_lock);
+    
+    /* Notify ALSA about mute state change for synchronization with alsamixer */
+    if (i2s_tdm->mute_kcontrol && i2s_tdm->dai && i2s_tdm->dai->component) {
+        snd_ctl_notify(i2s_tdm->dai->component->card->snd_card, SNDRV_CTL_EVENT_MASK_VALUE, &i2s_tdm->mute_kcontrol->id);
+    }
+    
+    return count;
+}
+
+static DEVICE_ATTR(mute, 0644, mute_show, mute_store);
+
+
+/* Main ALSA controls */
+static struct snd_kcontrol_new rockchip_i2s_tdm_volume_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Volume",
+    .info = rockchip_i2s_tdm_volume_info,
+    .get = rockchip_i2s_tdm_volume_get,
+    .put = rockchip_i2s_tdm_volume_put,
+};
+
+static struct snd_kcontrol_new rockchip_i2s_tdm_mute_control = {
+    .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+    .name = "PCM Playback Switch",
+    .info = rockchip_i2s_tdm_mute_info,
+    .get = rockchip_i2s_tdm_mute_get,
+    .put = rockchip_i2s_tdm_mute_put,
+};
+
+
+/* PCM copy callback for audio data processing */
+static int rockchip_i2s_tdm_pcm_copy_user(struct snd_soc_component *component,
+                                          struct snd_pcm_substream *substream,
+                                          int channel, unsigned long pos,
+                                          void __user *buf, unsigned long bytes)
+{
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    void *dma_area;
+    static int copy_call_count = 0;
+    
+    /* Get our driver through component */
+    i2s_tdm = snd_soc_component_get_drvdata(component);
+    if (!i2s_tdm) {
+        /* Debug message only for first calls */
+        if (copy_call_count < 3) {
+            dev_warn(component->dev, "Failed to get I2S TDM device from component (call %d)\n", copy_call_count++);
+        }
+        /* Fallback: standard copying without processing */
+        dma_area = substream->runtime->dma_area + pos;
+        if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+            return copy_from_user(dma_area, buf, bytes) ? -EFAULT : 0;
+        } else {
+            return copy_to_user(buf, dma_area, bytes) ? -EFAULT : 0;
+        }
+    }
+    
+    /* Get pointer to DMA buffer */
+    dma_area = substream->runtime->dma_area + pos;
+    if (!dma_area) {
+        dev_err(component->dev, "Invalid DMA area\n");
+        return -EINVAL;
+    }
+    
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        /* PLAYBACK: copy from user and process */
+        if (copy_from_user(dma_area, buf, bytes))
+            return -EFAULT;
+        
+        /* DSD MUTE: Replace data with silence signal (50% duty cycle) */
+        if ((i2s_tdm->mute || i2s_tdm->auto_mute_active) && i2s_tdm->dsd_mode_active &&
+            (substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_LE || 
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_BE ||
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U16_LE) && 
+            bytes >= 4) {
+            
+            /* For DSD silence = 50% duty cycle meander within each byte */
+            uint8_t *data = (uint8_t *)dma_area;
+            uint32_t i;
+            
+            for (i = 0; i < bytes; i++) {
+                data[i] = 0x55;  /* 01010101 - perfect 50% duty cycle meander for DSD silence */
+            }
+            
+            dev_dbg(i2s_tdm->dev, "DSD Mute: replaced %lu bytes with silence signal\n", bytes);
+            
+            /* During mute do not apply sample swap - send clean silence signal */
+            goto skip_dsd_processing;
+        }
+
+        /* PCM MUTE: Replace data with silence (0 volume) */
+        if ((i2s_tdm->mute || i2s_tdm->auto_mute_active) && !i2s_tdm->dsd_mode_active) {
+            memset(dma_area, 0, bytes);
+            dev_dbg(i2s_tdm->dev, "PCM Mute: replaced %lu bytes with silence\n", bytes);
+            goto skip_volume_processing;
+        }
+
+        /* Simple volume control with linear scaling */
+        if (i2s_tdm->volume < 100 && !i2s_tdm->dsd_mode_active) {
+            int volume_percent = i2s_tdm->volume;
+            int32_t volume_linear = (volume_percent * 65536) / 100; /* Simple linear scaling */
+            int format = substream->runtime->format;
+            int i;
+
+            /* Handle different bit depths with pseudo-logarithmic scaling */
+            if (format == SNDRV_PCM_FORMAT_S16_LE) {
+                /* 16-bit samples */
+                s16 *samples = (s16 *)dma_area;
+                int num_samples = bytes / 2;
+                
+                for (i = 0; i < num_samples; i++) {
+                    /* Apply pseudo-logarithmic volume using Q15.16 format */
+                    s64 scaled = (s64)samples[i] * volume_linear;
+                    samples[i] = (s16)(scaled >> 16);
+                }
+            } else if (format == SNDRV_PCM_FORMAT_S24_LE || format == SNDRV_PCM_FORMAT_S32_LE) {
+                /* 24-bit or 32-bit samples - use 64-bit math with pseudo-logarithmic scaling */
+                s32 *samples = (s32 *)dma_area;
+                int num_samples = bytes / 4;
+                
+                for (i = 0; i < num_samples; i++) {
+                    /* Apply pseudo-logarithmic volume using Q15.16 format */
+                    s64 scaled = (s64)samples[i] * volume_linear;
+                    samples[i] = (s32)(scaled >> 16);
+                }
+            } else if (format == SNDRV_PCM_FORMAT_S24_3LE) {
+                /* 24-bit packed samples (3 bytes per sample) */
+                u8 *data = (u8 *)dma_area;
+                int num_samples = bytes / 3;
+                
+                for (i = 0; i < num_samples; i++) {
+                    int sample_offset = i * 3;
+                    /* Convert 3-byte little-endian to s32 */
+                    s32 sample = (data[sample_offset] | 
+                                 (data[sample_offset + 1] << 8) | 
+                                 (data[sample_offset + 2] << 16));
+                    
+                    /* Sign extend from 24-bit */
+                    if (sample & 0x800000)
+                        sample |= 0xFF000000;
+                    
+                    /* Apply pseudo-logarithmic volume using Q15.16 format */
+                    s64 scaled = (s64)sample * volume_linear;
+                    sample = (s32)(scaled >> 16);
+                    
+                    /* Convert back to 3-byte little-endian */
+                    data[sample_offset] = sample & 0xFF;
+                    data[sample_offset + 1] = (sample >> 8) & 0xFF;
+                    data[sample_offset + 2] = (sample >> 16) & 0xFF;
+                }
+            }
+        }
+
+        /* CRITICAL FIX FOR DSD: Swap upper and lower 16 bits */
+        if (i2s_tdm->dsd_sample_swap && i2s_tdm->dsd_mode_active &&
+            (substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_LE || 
+             substream->runtime->format == SNDRV_PCM_FORMAT_DSD_U32_BE) && 
+            bytes >= 4 && (bytes % 4) == 0) {
+            
+            uint32_t *samples = (uint32_t *)dma_area;
+            uint32_t total_samples = bytes / 4;
+            uint32_t i;
+            
+            for (i = 0; i < total_samples; i++) {
+                /* Swap upper and lower 16 bits: ABCD -> CDAB */
+                uint32_t sample = samples[i];
+                samples[i] = ((sample & 0xFFFF0000) >> 16) | ((sample & 0x0000FFFF) << 16);
+            }
+        }
+        
+    skip_dsd_processing:
+    skip_volume_processing:
+        /* Debug message only for first calls */
+        if (copy_call_count < 3) {
+            dev_info(i2s_tdm->dev, "PCM copy: %lu bytes, simple volume control (call %d)\n", 
+                     bytes, copy_call_count++);
+        } else if (copy_call_count == 3) {
+            dev_info(i2s_tdm->dev, "PCM copy working, suppressing further debug messages\n");
+            copy_call_count++;
+        }
+        
+        dev_dbg(i2s_tdm->dev, "Processed %lu bytes for playback\n", bytes);
+    } else {
+        /* CAPTURE: simply copy to user */
+        if (copy_to_user(buf, dma_area, bytes))
+            return -EFAULT;
+    }
+    
+    return 0;
+}
+
+/* DSD rates for RoonReady compatibility */
+static const unsigned int dsd_rates[] = {
+    2822400,   /* DSD64 */
+    5644800,   /* DSD128 */
+    11289600,  /* DSD256 */
+    22579200,  /* DSD512 */
+};
+
+/* Add pause/resume support to PCM hardware */
+static const struct snd_pcm_hardware rockchip_i2s_tdm_pcm_hardware = {
+    .info = SNDRV_PCM_INFO_MMAP |
+        SNDRV_PCM_INFO_MMAP_VALID |
+        SNDRV_PCM_INFO_INTERLEAVED |
+        SNDRV_PCM_INFO_PAUSE |        /* Pause support */
+        SNDRV_PCM_INFO_RESUME |       /* Resume support */
+        SNDRV_PCM_INFO_BLOCK_TRANSFER,
+    .formats = SNDRV_PCM_FMTBIT_S8 |
+       SNDRV_PCM_FMTBIT_S16_LE |
+       SNDRV_PCM_FMTBIT_S20_3LE |
+       SNDRV_PCM_FMTBIT_S24_LE |
+       SNDRV_PCM_FMTBIT_S32_LE |
+       SNDRV_PCM_FMTBIT_DSD_U16_LE |
+       SNDRV_PCM_FMTBIT_DSD_U32_LE,
+    .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+    .rate_min = 8000,
+    .rate_max = 22579200,  /* DSD512 support (22.5792 MHz) */
+    .channels_min = 2,
+    .channels_max = 16,
+    .buffer_bytes_max = 1024 * 1024,  /* 1MB maximum for ultimate stability */
+    .period_bytes_min = 8192,         
+    .period_bytes_max = 64 * 1024,    /* 64KB maximum for deep buffering */
+    .periods_min = 16,                
+    .periods_max = 512,
+    .fifo_size = 512,  /* Increased from 256 to 512 for maximum buffering on single-core ARM */
+};
+
+static const struct snd_dmaengine_pcm_config rockchip_i2s_tdm_dmaengine_pcm_config = {
+    .pcm_hardware = &rockchip_i2s_tdm_pcm_hardware,
+    .prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+    .prealloc_buffer_size = 1024 * 1024,  /* 1MB preallocation for ultimate stability */
+};
+
+/* Component probe function to set driver data */
+static int rockchip_i2s_tdm_component_probe(struct snd_soc_component *component)
+{
+    struct device *dev = component->dev;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    
+    /* Get our driver from platform device */
+    i2s_tdm = dev_get_drvdata(dev);
+    if (!i2s_tdm) {
+        dev_err(dev, "Failed to get I2S TDM device data in component probe\n");
+        return -ENODEV;
+    }
+    
+    /* Set driver data for component */
+    snd_soc_component_set_drvdata(component, i2s_tdm);
+    
+    dev_info(dev, "Audiophile component probe: driver data set successfully\n");
+    
+    return 0;
+}
+
+/* Alternative way through ioctl for older ALSA versions */
+static int rockchip_i2s_tdm_pcm_ioctl(struct snd_soc_component *component,
+                                      struct snd_pcm_substream *substream,
+                                      unsigned int cmd, void *arg)
+{
+    /* Standard ioctl without additional processing */
+    return snd_pcm_lib_ioctl(substream, cmd, arg);
+}
+
+
+/* Component with copy callbacks support */
+static const struct snd_soc_component_driver rockchip_i2s_tdm_component_with_copy = {
+    .name = DRV_NAME,
+    .probe = rockchip_i2s_tdm_component_probe,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
+    .copy_user = rockchip_i2s_tdm_pcm_copy_user, /* DSD processing + simple volume */
+    .ioctl = rockchip_i2s_tdm_pcm_ioctl,
 };
 
 static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    int ret;
 
-	if (i2s_tdm->has_capture)
-		dai->capture_dma_data = &i2s_tdm->capture_dma_data;
-	if (i2s_tdm->has_playback)
-		dai->playback_dma_data = &i2s_tdm->playback_dma_data;
-
-	if (i2s_tdm->mclk_calibrate)
-		snd_soc_add_component_controls(dai->component,
-					       &rockchip_i2s_tdm_compensation_control,
-					       1);
+    dai->capture_dma_data = &i2s_tdm->capture_dma_data;
+    dai->playback_dma_data = &i2s_tdm->playback_dma_data;
 
-	return 0;
+    dev_info(i2s_tdm->dev, "Audiophile processing DISABLED - using standard ALSA\n");
+
+    if (i2s_tdm->mclk_calibrate) {
+        ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_compensation_control, 1);
+        if (ret)
+            dev_err(i2s_tdm->dev, "Failed to add compensation control: %d\n", ret);
+    }
+
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_volume_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add volume control: %d\n", ret);
+    else
+        dev_info(i2s_tdm->dev, "Basic volume control added (no processing)\n");
+
+    ret = snd_soc_add_dai_controls(dai, &rockchip_i2s_tdm_mute_control, 1);
+    if (ret)
+        dev_err(i2s_tdm->dev, "Failed to add mute control: %d\n", ret);
+    else {
+        dev_info(i2s_tdm->dev, "Basic mute control added (no processing)\n");
+        /* Save pointers for automute system */
+        i2s_tdm->mute_kcontrol = snd_soc_card_get_kcontrol(dai->component->card, rockchip_i2s_tdm_mute_control.name);
+        i2s_tdm->dai = dai;
+    }
+
+    return 0;
 }
 
 static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
-				 unsigned int tx_mask, unsigned int rx_mask,
-				 int slots, int slot_width)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	unsigned int mask, val, wl, fifos;
-	int ret;
-
-	i2s_tdm->tdm_mode = true;
-	i2s_tdm->tdm_slots = slots;
-	i2s_tdm->frame_width = slots * slot_width;
-
-	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
-	val = TDM_SLOT_BIT_WIDTH(slot_width) |
-	      TDM_FRAME_WIDTH(slots * slot_width);
-
-	ret = pm_runtime_resume_and_get(dai->dev);
-	if (ret < 0 && ret != -EACCES)
-		return ret;
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR, mask, val);
-	regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR, mask, val);
-
-	mask = I2S_TXCR_VDW_MASK;
-	val = I2S_TXCR_VDW(slot_width);
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_TXCR, mask, val);
-	regmap_update_bits(i2s_tdm->regmap, I2S_RXCR, mask, val);
-	/*
-	 * TDM mode use all FIFOs, the max burst is 16 word of DMAC,
-	 * so we used the max FIFO to cover DDR dmc windows.
-	 *
-	 * 4 FIFOs controller:
-	 *
-	 * TDL:
-	 *
-	 * 16 word: WL = ((32 * 4) - 16) / 4 = 28
-	 *
-	 * RDL:
-	 *
-	 * 16 word: WL = 16 / 4 = 4
-	 */
-	if (!i2s_tdm->tdm_fsync_half_frame)
-		fifos = slots / 4;
-	else
-		fifos = slots / 2;
-
-	if (!fifos)
-		fifos = 1;
-
-	/* RK3568 I2S2/I2S3 TDM has only one FIFO */
-	if (strstr(dev_name(dai->dev), "fe420000") || strstr(dev_name(dai->dev), "fe430000"))
-		fifos = 1;
-
-	wl = ((DEPTH_PER_FIFO * fifos) - MAXBURST) / fifos;
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
-			   I2S_DMACR_TDL(wl));
-	wl = MAXBURST / fifos;
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
-			   I2S_DMACR_RDL(wl));
-
-	pm_runtime_put(dai->dev);
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_set_bclk_ratio(struct snd_soc_dai *dai,
-					   unsigned int ratio)
+     unsigned int tx_mask, unsigned int rx_mask,
+     int slots, int slot_width)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+    unsigned int mask, val;
 
-	if (ratio < 32 || ratio > 512 || ratio % 2 == 1)
-		return -EINVAL;
+    i2s_tdm->tdm_mode = true;
+    i2s_tdm->bclk_fs = slots * slot_width;
+    mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
+    val = TDM_SLOT_BIT_WIDTH(slot_width) |
+          TDM_FRAME_WIDTH(slots * slot_width);
+
+    pm_runtime_get_sync(dai->dev);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_TXCR,
+           mask, val);
+    regmap_update_bits(i2s_tdm->regmap, I2S_TDM_RXCR,
+           mask, val);
+    pm_runtime_put(dai->dev);
 
-	i2s_tdm->frame_width = ratio;
-
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_startup(struct snd_pcm_substream *substream,
-				    struct snd_soc_dai *dai)
+        struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-	int stream = substream->stream;
-
-	if (!rockchip_i2s_tdm_stream_valid(substream, dai))
-		return 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	if (i2s_tdm->substreams[stream])
-		return -EBUSY;
+    if (i2s_tdm->substreams[substream->stream])
+    return -EBUSY;
 
-	if (i2s_tdm->wait_time[stream])
-		substream->wait_time = msecs_to_jiffies(i2s_tdm->wait_time[stream]);
+    i2s_tdm->substreams[substream->stream] = substream;
 
-	i2s_tdm->substreams[stream] = substream;
+    /* Export DSD rates for userspace applications like RoonReady */
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        dev_info(i2s_tdm->dev, "DSD support available: 2.8M, 5.6M, 11.2M, 22.5M Hz\n");
+    }
 
-	return 0;
+    return 0;
 }
 
 static void rockchip_i2s_tdm_shutdown(struct snd_pcm_substream *substream,
-				      struct snd_soc_dai *dai)
+          struct snd_soc_dai *dai)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
-
-	if (!rockchip_i2s_tdm_stream_valid(substream, dai))
-		return;
+    struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 
-	i2s_tdm->substreams[substream->stream] = NULL;
-}
-
-static int rockchip_i2s_tdm_comp_resume(struct snd_soc_component *component)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_component_get_drvdata(component);
-
-	if (i2s_tdm->resume_deferred_ms)
-		msleep(i2s_tdm->resume_deferred_ms);
-
-	dev_dbg(component->dev, "%s: resume deferred %d ms\n",
-		__func__, i2s_tdm->resume_deferred_ms);
-
-	return 0;
+    i2s_tdm->substreams[substream->stream] = NULL;
 }
 
 static const struct snd_soc_dai_ops rockchip_i2s_tdm_dai_ops = {
-	.startup = rockchip_i2s_tdm_startup,
-	.shutdown = rockchip_i2s_tdm_shutdown,
-	.hw_params = rockchip_i2s_tdm_hw_params,
-	.hw_free = rockchip_i2s_tdm_hw_free,
-	.set_bclk_ratio	= rockchip_i2s_tdm_set_bclk_ratio,
-	.set_sysclk = rockchip_i2s_tdm_set_sysclk,
-	.set_fmt = rockchip_i2s_tdm_set_fmt,
-	.set_tdm_slot = rockchip_dai_tdm_slot,
-	.trigger = rockchip_i2s_tdm_trigger,
+    .startup = rockchip_i2s_tdm_startup,
+    .shutdown = rockchip_i2s_tdm_shutdown,
+    .hw_params = rockchip_i2s_tdm_hw_params,
+    .set_sysclk = rockchip_i2s_tdm_set_sysclk,
+    .set_fmt = rockchip_i2s_tdm_set_fmt,
+    .set_tdm_slot = rockchip_dai_tdm_slot,
+    .trigger = rockchip_i2s_tdm_trigger,
 };
 
 static const struct snd_soc_component_driver rockchip_i2s_tdm_component = {
-	.name = DRV_NAME,
-	.legacy_dai_naming = 1,
-	.controls = rockchip_i2s_tdm_snd_controls,
-	.num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
-	.resume = rockchip_i2s_tdm_comp_resume,
+    .name = DRV_NAME,
+    .controls = rockchip_i2s_tdm_snd_controls,
+    .num_controls = ARRAY_SIZE(rockchip_i2s_tdm_snd_controls),
 };
 
 static bool rockchip_i2s_tdm_wr_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_rd_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXCR:
-	case I2S_RXCR:
-	case I2S_CKR:
-	case I2S_DMACR:
-	case I2S_INTCR:
-	case I2S_XFER:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_TXFIFOLR:
-	case I2S_INTSR:
-	case I2S_RXFIFOLR:
-	case I2S_TDM_TXCR:
-	case I2S_TDM_RXCR:
-	case I2S_CLKDIV:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXCR:
+    case I2S_RXCR:
+    case I2S_CKR:
+    case I2S_DMACR:
+    case I2S_INTCR:
+    case I2S_XFER:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_TXFIFOLR:
+    case I2S_INTSR:
+    case I2S_RXFIFOLR:
+    case I2S_TDM_TXCR:
+    case I2S_TDM_RXCR:
+    case I2S_CLKDIV:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_volatile_reg(struct device *dev, unsigned int reg)
 {
-	switch (reg) {
-	case I2S_TXFIFOLR:
-	case I2S_INTCR:
-	case I2S_INTSR:
-	case I2S_CLR:
-	case I2S_TXDR:
-	case I2S_RXDR:
-	case I2S_RXFIFOLR:
-		return true;
-	default:
-		return false;
-	}
+    switch (reg) {
+    case I2S_TXFIFOLR:
+    case I2S_INTCR:
+    case I2S_INTSR:
+    case I2S_CLR:
+    case I2S_TXDR:
+    case I2S_RXDR:
+    case I2S_RXFIFOLR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static bool rockchip_i2s_tdm_precious_reg(struct device *dev, unsigned int reg)
 {
-	if (reg == I2S_RXDR)
-		return true;
-	return false;
+    switch (reg) {
+    case I2S_RXDR:
+    return true;
+    default:
+    return false;
+    }
 }
 
 static const struct reg_default rockchip_i2s_tdm_reg_defaults[] = {
-	{0x00, 0x7200000f},
-	{0x04, 0x01c8000f},
-	{0x08, 0x00001f1f},
-	{0x10, 0x001f0000},
-	{0x14, 0x01f00000},
-	{0x30, 0x00003eff},
-	{0x34, 0x00003eff},
-	{0x38, 0x00000707},
+    {0x00, 0x7200000f},
+    {0x04, 0x01c8000f},
+    {0x08, 0x00001f1f},
+    {0x10, 0x001f0000},
+    {0x14, 0x01f00000},
+    {0x30, 0x00003eff},
+    {0x34, 0x00003eff},
+    {0x38, 0x00000707},
 };
 
 static const struct regmap_config rockchip_i2s_tdm_regmap_config = {
-	.reg_bits = 32,
-	.reg_stride = 4,
-	.val_bits = 32,
-	.max_register = I2S_CLKDIV,
-	.reg_defaults = rockchip_i2s_tdm_reg_defaults,
-	.num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
-	.writeable_reg = rockchip_i2s_tdm_wr_reg,
-	.readable_reg = rockchip_i2s_tdm_rd_reg,
-	.volatile_reg = rockchip_i2s_tdm_volatile_reg,
-	.precious_reg = rockchip_i2s_tdm_precious_reg,
-	.cache_type = REGCACHE_FLAT,
+    .reg_bits = 32,
+    .reg_stride = 4,
+    .val_bits = 32,
+    .max_register = I2S_CLKDIV,
+    .reg_defaults = rockchip_i2s_tdm_reg_defaults,
+    .num_reg_defaults = ARRAY_SIZE(rockchip_i2s_tdm_reg_defaults),
+    .writeable_reg = rockchip_i2s_tdm_wr_reg,
+    .readable_reg = rockchip_i2s_tdm_rd_reg,
+    .volatile_reg = rockchip_i2s_tdm_volatile_reg,
+    .precious_reg = rockchip_i2s_tdm_precious_reg,
+    .cache_type = REGCACHE_FLAT,
 };
 
 static int common_soc_init(struct device *dev, u32 addr)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
-	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
-	int i;
-
-	if (trcm == TRCM_TXRX)
-		return 0;
-
-	if (IS_ERR(i2s_tdm->grf))
-		return 0;
-
-	for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
-		if (addr != configs[i].addr)
-			continue;
-		reg = configs[i].reg;
-		if (trcm == TRCM_TX)
-			val = configs[i].txonly;
-		else
-			val = configs[i].rxonly;
-
-		if (reg)
-			regmap_write(i2s_tdm->grf, reg, val);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    const struct txrx_config *configs = i2s_tdm->soc_data->configs;
+    u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
+    int i;
+
+    dev_info(dev, "common_soc_init called: addr=0x%08x, trcm=%u\n", addr, trcm);
+
+    if (IS_ERR(i2s_tdm->grf)) {
+        dev_err(dev, "GRF is not available (error)\n");
+        return 0;
+    }
+
+    switch (trcm) {
+    case I2S_CKR_TRCM_TXONLY:
+        dev_info(dev, "TRCM mode: TXONLY\n");
+        break;
+    case I2S_CKR_TRCM_RXONLY:
+        dev_info(dev, "TRCM mode: RXONLY\n");
+        break;
+    default:
+        dev_info(dev, "TRCM mode not TXONLY/RXONLY (%u), skipping GRF config\n", trcm);
+        return 0;
+    }
+
+    dev_info(dev, "Searching for matching config (count=%u)...\n", i2s_tdm->soc_data->config_count);
+    for (i = 0; i < i2s_tdm->soc_data->config_count; i++) {
+        dev_info(dev, "  Config[%d]: addr=0x%08x, reg=0x%x\n", i, configs[i].addr, configs[i].reg);
+        if (addr != configs[i].addr)
+            continue;
+        reg = configs[i].reg;
+        if (trcm == I2S_CKR_TRCM_TXONLY)
+            val = configs[i].txonly;
+        else
+            val = configs[i].rxonly;
+
+        if (reg) {
+            dev_info(dev, "Writing GRF: reg=0x%x, val=0x%x (MCLKOUT source config)\n", reg, val);
+            regmap_write(i2s_tdm->grf, reg, val);
+        } else {
+            dev_warn(dev, "Config matched but reg=0!\n");
+        }
+    }
 
-	return 0;
+    return 0;
 }
 
 static const struct txrx_config px30_txrx_config[] = {
-	{ 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
+    { 0xff060000, 0x184, PX30_I2S0_CLK_TXONLY, PX30_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk1808_txrx_config[] = {
-	{ 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
+    { 0xff7e0000, 0x190, RK1808_I2S0_CLK_TXONLY, RK1808_I2S0_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3308_txrx_config[] = {
-	{ 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
-	{ 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
+    { 0xff300000, 0x308, RK3308_I2S0_CLK_TXONLY, RK3308_I2S0_CLK_RXONLY },
+    { 0xff310000, 0x308, RK3308_I2S1_CLK_TXONLY, RK3308_I2S1_CLK_RXONLY },
 };
 
 static const struct txrx_config rk3568_txrx_config[] = {
-	{ 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
-	{ 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
-	{ 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
+    { 0xfe410000, 0x504, RK3568_I2S1_CLK_TXONLY, RK3568_I2S1_CLK_RXONLY },
+    { 0xfe430000, 0x504, RK3568_I2S3_CLK_TXONLY, RK3568_I2S3_CLK_RXONLY },
+    { 0xfe430000, 0x508, RK3568_I2S3_MCLK_TXONLY, RK3568_I2S3_MCLK_RXONLY },
 };
 
 static const struct txrx_config rv1126_txrx_config[] = {
-	{ 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
+    { 0xff800000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
+};
+
+static const struct txrx_config rv1106_txrx_config[] = {
+    { 0xffae0000, 0x10260, RV1126_I2S0_CLK_TXONLY, RV1126_I2S0_CLK_RXONLY },
 };
 
 static const struct rk_i2s_soc_data px30_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = px30_txrx_config,
-	.config_count = ARRAY_SIZE(px30_txrx_config),
-	.init = common_soc_init,
-#ifdef HAVE_SYNC_RESET
-	.src_clk_ctrl = rockchip_i2s_tdm_px30_src_clk_ctrl,
-#endif
+    .softrst_offset = 0x0300,
+    .configs = px30_txrx_config,
+    .config_count = ARRAY_SIZE(px30_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk1808_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rk1808_txrx_config,
-	.config_count = ARRAY_SIZE(rk1808_txrx_config),
-	.init = common_soc_init,
-#ifdef HAVE_SYNC_RESET
-	.src_clk_ctrl = rockchip_i2s_tdm_rk1808_src_clk_ctrl,
-#endif
+    .softrst_offset = 0x0300,
+    .configs = rk1808_txrx_config,
+    .config_count = ARRAY_SIZE(rk1808_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3308_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.grf_reg_offset = 0x0308,
-	.grf_shift = 5,
-	.configs = rk3308_txrx_config,
-	.config_count = ARRAY_SIZE(rk3308_txrx_config),
-	.init = common_soc_init,
-#ifdef HAVE_SYNC_RESET
-	.src_clk_ctrl = rockchip_i2s_tdm_rk3308_src_clk_ctrl,
-#endif
+    .softrst_offset = 0x0400,
+    .grf_reg_offset = 0x0308,
+    .grf_shift = 5,
+    .configs = rk3308_txrx_config,
+    .config_count = ARRAY_SIZE(rk3308_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rk3568_i2s_soc_data = {
-	.softrst_offset = 0x0400,
-	.configs = rk3568_txrx_config,
-	.config_count = ARRAY_SIZE(rk3568_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0400,
+    .configs = rk3568_txrx_config,
+    .config_count = ARRAY_SIZE(rk3568_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct rk_i2s_soc_data rv1126_i2s_soc_data = {
-	.softrst_offset = 0x0300,
-	.configs = rv1126_txrx_config,
-	.config_count = ARRAY_SIZE(rv1126_txrx_config),
-	.init = common_soc_init,
+    .softrst_offset = 0x0300,
+    .configs = rv1126_txrx_config,
+    .config_count = ARRAY_SIZE(rv1126_txrx_config),
+    .init = common_soc_init,
+};
+
+static const struct rk_i2s_soc_data rv1106_i2s_soc_data = {
+    .softrst_offset = 0x0300,
+    .configs = rv1106_txrx_config,
+    .config_count = ARRAY_SIZE(rv1106_txrx_config),
+    .init = common_soc_init,
 };
 
 static const struct of_device_id rockchip_i2s_tdm_match[] = {
 #ifdef CONFIG_CPU_PX30
-	{ .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
+    { .compatible = "rockchip,px30-i2s-tdm", .data = &px30_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK1808
-	{ .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
+    { .compatible = "rockchip,rk1808-i2s-tdm", .data = &rk1808_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3308
-	{ .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
+    { .compatible = "rockchip,rk3308-i2s-tdm", .data = &rk3308_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3568
-	{ .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
+    { .compatible = "rockchip,rk3568-i2s-tdm", .data = &rk3568_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RK3588
-	{ .compatible = "rockchip,rk3588-i2s-tdm", },
+    { .compatible = "rockchip,rk3588-i2s-tdm", },
 #endif
 #ifdef CONFIG_CPU_RV1106
-	{ .compatible = "rockchip,rv1106-i2s-tdm", },
+    { .compatible = "rockchip,rv1106-i2s-tdm", .data = &rv1106_i2s_soc_data },
 #endif
 #ifdef CONFIG_CPU_RV1126
-	{ .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
+    { .compatible = "rockchip,rv1126-i2s-tdm", .data = &rv1126_i2s_soc_data },
 #endif
-	{},
+    {},
 };
 
-static const struct snd_soc_dai_driver i2s_tdm_dai = {
-	.probe = rockchip_i2s_tdm_dai_probe,
-	.ops = &rockchip_i2s_tdm_dai_ops,
-};
-
-static int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	struct snd_soc_dai_driver *dai;
-	struct property *dma_names;
-	const char *dma_name;
-	u64 formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |
-		       SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
-		       SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE);
-	struct device_node *node = i2s_tdm->dev->of_node;
-
-	of_property_for_each_string(node, "dma-names", dma_names, dma_name) {
-		if (!strcmp(dma_name, "tx"))
-			i2s_tdm->has_playback = true;
-		if (!strcmp(dma_name, "rx"))
-			i2s_tdm->has_capture = true;
-	}
-
-	dai = devm_kmemdup(i2s_tdm->dev, &i2s_tdm_dai,
-			   sizeof(*dai), GFP_KERNEL);
-	if (!dai)
-		return -ENOMEM;
-
-	if (i2s_tdm->has_playback) {
-		dai->playback.stream_name  = "Playback";
-		dai->playback.channels_min = 2;
-		dai->playback.channels_max = 64;
-		dai->playback.rates = SNDRV_PCM_RATE_CONTINUOUS;
-		dai->playback.formats = formats;
-	}
-
-	if (i2s_tdm->has_capture) {
-		dai->capture.stream_name  = "Capture";
-		dai->capture.channels_min = 2;
-		dai->capture.channels_max = 64;
-		dai->capture.rates = SNDRV_PCM_RATE_CONTINUOUS;
-		dai->capture.formats = formats;
-	}
-
-	if (i2s_tdm->clk_trcm != TRCM_TXRX)
-		dai->symmetric_rate = 1;
-
-	i2s_tdm->dai = dai;
+#ifdef HAVE_SYNC_RESET
+static int of_i2s_resetid_get(struct device_node *node,
+              const char *id)
+{
+    struct of_phandle_args args;
+    int index = 0;
+    int ret;
+
+    if (id)
+    index = of_property_match_string(node,
+         "reset-names", id);
+    ret = of_parse_phandle_with_args(node, "resets", "#reset-cells",
+         index, &args);
+    if (ret)
+    return ret;
+
+    return args.args[0];
+}
+#endif
+
+static int rockchip_i2s_tdm_dai_prepare(struct platform_device *pdev,
+        struct snd_soc_dai_driver **soc_dai)
+{
+    struct snd_soc_dai_driver rockchip_i2s_tdm_dai = {
+    .name = DRV_NAME,
+    .probe = rockchip_i2s_tdm_dai_probe,
+    .playback = {
+        .stream_name = "Playback",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+        .rate_min = 8000,
+        .rate_max = 22579200,  /* DSD512 support */
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |
+        SNDRV_PCM_FMTBIT_DSD_U16_LE |
+        SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .channels_min = 2,
+        .channels_max = 16,
+        .rates = SNDRV_PCM_RATE_8000_384000 | SNDRV_PCM_RATE_KNOT,
+        .rate_min = 8000,
+        .rate_max = 22579200,  /* DSD512 support */
+        .formats = (SNDRV_PCM_FMTBIT_S8 |
+        SNDRV_PCM_FMTBIT_S16_LE |
+        SNDRV_PCM_FMTBIT_S20_3LE |
+        SNDRV_PCM_FMTBIT_S24_LE |
+        SNDRV_PCM_FMTBIT_S32_LE |
+        SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE |
+        SNDRV_PCM_FMTBIT_DSD_U16_LE |
+        SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .ops = &rockchip_i2s_tdm_dai_ops,
+    };
+
+    *soc_dai = devm_kmemdup(&pdev->dev, &rockchip_i2s_tdm_dai,
+    sizeof(rockchip_i2s_tdm_dai), GFP_KERNEL);
+    if (!(*soc_dai))
+    return -ENOMEM;
 
-	return 0;
+    return 0;
 }
 
 static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
-				       int num,
-				       bool is_rx_path)
+           int num,
+           bool is_rx_path)
 {
-	unsigned int *i2s_data;
-	int i, j;
+    unsigned int *i2s_data;
+    int i, j, ret = 0;
 
-	if (is_rx_path)
-		i2s_data = i2s_tdm->i2s_sdis;
-	else
-		i2s_data = i2s_tdm->i2s_sdos;
-
-	for (i = 0; i < num; i++) {
-		if (i2s_data[i] > CH_GRP_MAX - 1) {
-			dev_err(i2s_tdm->dev,
-				"%s path i2s_data[%d]: %d is too high, max is: %d\n",
-				is_rx_path ? "RX" : "TX",
-				i, i2s_data[i], CH_GRP_MAX);
-			return -EINVAL;
-		}
-
-		for (j = 0; j < num; j++) {
-			if (i == j)
-				continue;
-
-			if (i2s_data[i] == i2s_data[j]) {
-				dev_err(i2s_tdm->dev,
-					"%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
-					is_rx_path ? "RX" : "TX",
-					i, i2s_data[i],
-					j, i2s_data[j]);
-				return -EINVAL;
-			}
-		}
-	}
+    if (is_rx_path)
+    i2s_data = i2s_tdm->i2s_sdis;
+    else
+    i2s_data = i2s_tdm->i2s_sdos;
+
+    for (i = 0; i < num; i++) {
+    if (i2s_data[i] > CH_GRP_MAX - 1) {
+        dev_err(i2s_tdm->dev,
+    "%s path i2s_data[%d]: %d is overflow, max is: %d\n",
+    is_rx_path ? "RX" : "TX",
+    i, i2s_data[i], CH_GRP_MAX);
+        ret = -EINVAL;
+        goto err;
+    }
+
+    for (j = 0; j < num; j++) {
+        if (i == j)
+    continue;
+
+        if (i2s_data[i] == i2s_data[j]) {
+    dev_err(i2s_tdm->dev,
+        "%s path invalid routed i2s_data: [%d]%d == [%d]%d\n",
+        is_rx_path ? "RX" : "TX",
+        i, i2s_data[i],
+        j, i2s_data[j]);
+    ret = -EINVAL;
+    goto err;
+        }
+    }
+    }
 
-	return 0;
+err:
+    return ret;
 }
 
 static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
+
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
-				   I2S_TXCR_PATH_MASK(idx),
-				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
+       I2S_TXCR_PATH_MASK(idx),
+       I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					    int num)
+            int num)
 {
-	int idx;
+    int idx;
 
-	for (idx = 0; idx < num; idx++) {
-		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
-				   I2S_RXCR_PATH_MASK(idx),
-				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
-	}
+    for (idx = 0; idx < num; idx++) {
+    regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
+       I2S_RXCR_PATH_MASK(idx),
+       I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
+    }
 }
 
 static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
-					 int num, bool is_rx_path)
+         int num, bool is_rx_path)
 {
-	if (is_rx_path)
-		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
-	else
-		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
-}
-
-static int rockchip_i2s_tdm_get_calibrate_mclks(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	int num_mclks = 0;
-
-	i2s_tdm->mclk_tx_src = devm_clk_get(i2s_tdm->dev, "mclk_tx_src");
-	if (!IS_ERR(i2s_tdm->mclk_tx_src))
-		num_mclks++;
-
-	i2s_tdm->mclk_rx_src = devm_clk_get(i2s_tdm->dev, "mclk_rx_src");
-	if (!IS_ERR(i2s_tdm->mclk_rx_src))
-		num_mclks++;
-
-	i2s_tdm->mclk_root0 = devm_clk_get(i2s_tdm->dev, "mclk_root0");
-	if (!IS_ERR(i2s_tdm->mclk_root0))
-		num_mclks++;
-
-	i2s_tdm->mclk_root1 = devm_clk_get(i2s_tdm->dev, "mclk_root1");
-	if (!IS_ERR(i2s_tdm->mclk_root1))
-		num_mclks++;
-
-	if (num_mclks < 4 && num_mclks != 0)
-		return -ENOENT;
-
-	if (num_mclks == 4)
-		i2s_tdm->mclk_calibrate = 1;
-
-	return 0;
-}
-
-static int rockchip_i2s_tdm_wait_time_init(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	unsigned int wait_time;
-
-	if (!device_property_read_u32(i2s_tdm->dev, "rockchip,i2s-tx-wait-time-ms", &wait_time)) {
-		dev_info(i2s_tdm->dev, "Init TX wait-time-ms: %d\n", wait_time);
-		i2s_tdm->wait_time[SNDRV_PCM_STREAM_PLAYBACK] = wait_time;
-	}
-
-	if (!device_property_read_u32(i2s_tdm->dev, "rockchip,i2s-rx-wait-time-ms", &wait_time)) {
-		dev_info(i2s_tdm->dev, "Init RX wait-time-ms: %d\n", wait_time);
-		i2s_tdm->wait_time[SNDRV_PCM_STREAM_CAPTURE] = wait_time;
-	}
-	return 0;
+    if (is_rx_path)
+    rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
+    else
+    rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
 }
 
 static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					 struct device_node *np,
-					 bool is_rx_path)
+         struct device_node *np,
+         bool is_rx_path)
 {
-	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
-	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
-	char *i2s_path_prop;
-	unsigned int *i2s_data;
-	int num, ret = 0;
-
-	if (is_rx_path) {
-		i2s_path_prop = i2s_rx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdis;
-	} else {
-		i2s_path_prop = i2s_tx_path_prop;
-		i2s_data = i2s_tdm->i2s_sdos;
-	}
-
-	num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
-	if (num < 0) {
-		if (num != -ENOENT) {
-			dev_err(i2s_tdm->dev,
-				"Failed to read '%s' num: %d\n",
-				i2s_path_prop, num);
-			ret = num;
-		}
-		return ret;
-	} else if (num != CH_GRP_MAX) {
-		dev_err(i2s_tdm->dev,
-			"The num: %d should be: %d\n", num, CH_GRP_MAX);
-		return -EINVAL;
-	}
-
-	ret = of_property_read_u32_array(np, i2s_path_prop,
-					 i2s_data, num);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to read '%s': %d\n",
-			i2s_path_prop, ret);
-		return ret;
-	}
-
-	ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
-	if (ret < 0) {
-		dev_err(i2s_tdm->dev,
-			"Failed to check i2s data bus: %d\n", ret);
-		return ret;
-	}
+    char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
+    char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
+    char *i2s_path_prop;
+    unsigned int *i2s_data;
+    int num, ret = 0;
+
+    if (is_rx_path) {
+    i2s_path_prop = i2s_rx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdis;
+    } else {
+    i2s_path_prop = i2s_tx_path_prop;
+    i2s_data = i2s_tdm->i2s_sdos;
+    }
+
+    num = of_count_phandle_with_args(np, i2s_path_prop, NULL);
+    if (num < 0) {
+    if (num != -ENOENT) {
+        dev_err(i2s_tdm->dev,
+    "Failed to read '%s' num: %d\n",
+    i2s_path_prop, num);
+        ret = num;
+    }
+    goto out;
+    } else if (num != CH_GRP_MAX) {
+    dev_err(i2s_tdm->dev,
+        "The num: %d should be: %d\n", num, CH_GRP_MAX);
+    ret = -EINVAL;
+    goto out;
+    }
+
+    ret = of_property_read_u32_array(np, i2s_path_prop,
+         i2s_data, num);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to read '%s': %d\n",
+        i2s_path_prop, ret);
+    goto out;
+    }
+
+    ret = rockchip_i2s_tdm_path_check(i2s_tdm, num, is_rx_path);
+    if (ret < 0) {
+    dev_err(i2s_tdm->dev,
+        "Failed to check i2s data bus: %d\n", ret);
+    goto out;
+    }
 
-	rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
+    rockchip_i2s_tdm_path_config(i2s_tdm, num, is_rx_path);
 
-	return 0;
+out:
+    return ret;
 }
 
 static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
 }
 
 static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
-					    struct device_node *np)
+            struct device_node *np)
 {
-	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
+    return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 1);
 }
 
-static int rockchip_i2s_tdm_get_fifo_count(struct device *dev,
-					   struct snd_pcm_substream *substream)
+static int rockchip_i2s_tdm_get_fifo_count(struct device *dev, struct snd_pcm_substream *substream)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int val = 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int val = 0;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
-	else
-		regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+    regmap_read(i2s_tdm->regmap, I2S_TXFIFOLR, &val);
+    else
+    regmap_read(i2s_tdm->regmap, I2S_RXFIFOLR, &val);
 
-	val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
-	      ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
+    val = ((val & I2S_FIFOLR_TFL3_MASK) >> I2S_FIFOLR_TFL3_SHIFT) +
+          ((val & I2S_FIFOLR_TFL2_MASK) >> I2S_FIFOLR_TFL2_SHIFT) +
+          ((val & I2S_FIFOLR_TFL1_MASK) >> I2S_FIFOLR_TFL1_SHIFT) +
+          ((val & I2S_FIFOLR_TFL0_MASK) >> I2S_FIFOLR_TFL0_SHIFT);
 
-	return val;
+    return val;
 }
 
 static const struct snd_dlp_config dconfig = {
-	.get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
+    .get_fifo_count = rockchip_i2s_tdm_get_fifo_count,
 };
 
 static irqreturn_t rockchip_i2s_tdm_isr(int irq, void *devid)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
-	struct snd_pcm_substream *substream;
-	u32 val;
-
-	regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
-	if (val & I2S_INTSR_TXUI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_TXUIE_MASK,
-				   I2S_INTCR_TXUIE(0));
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
-
-	if (val & I2S_INTSR_RXOI_ACT) {
-		dev_warn_ratelimited(i2s_tdm->dev, "RX FIFO Overrun\n");
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
-		regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
-				   I2S_INTCR_RXOIE_MASK,
-				   I2S_INTCR_RXOIE(0));
-		substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_CAPTURE];
-		if (substream)
-			snd_pcm_stop_xrun(substream);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int rockchip_i2s_tdm_keep_clk_always_on(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-	unsigned int mclk_rate = DEFAULT_FS * DEFAULT_MCLK_FS;
-	unsigned int bclk_rate = i2s_tdm->frame_width * DEFAULT_FS;
-	unsigned int div_lrck = i2s_tdm->frame_width;
-	unsigned int div_bclk;
-	int ret;
-
-	if (mclk_rate < bclk_rate)
-		mclk_rate = bclk_rate;
-
-	div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
-
-	/* assign generic freq */
-	clk_set_rate(i2s_tdm->mclk_rx, mclk_rate);
-	clk_set_rate(i2s_tdm->mclk_tx, mclk_rate);
+    struct rk_i2s_tdm_dev *i2s_tdm = (struct rk_i2s_tdm_dev *)devid;
+    struct snd_pcm_substream *substream;
+    u32 val;
+
+    regmap_read(i2s_tdm->regmap, I2S_INTSR, &val);
+
+    if (val & I2S_INTSR_TXUI_ACT) {
+    dev_warn_ratelimited(i2s_tdm->dev, "TX FIFO Underrun\n");
+    regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+       I2S_INTCR_TXUIC, I2S_INTCR_TXUIC);
+    substream = i2s_tdm->substreams[SNDRV_PCM_STREAM_PLAYBACK];
+    if (substream)
+        snd_pcm_stop_xrun(substream);
+    }
+
+    if (val & I2S_INTSR_RXOI_ACT) {
+        /* Silently clear RX FIFO Overrun for external clock mode
+         * RX is used only for clock sync at high sample rates (192kHz)
+         * Suppress logging to reduce CPU overhead */
+        regmap_update_bits(i2s_tdm->regmap, I2S_INTCR,
+           I2S_INTCR_RXOIC, I2S_INTCR_RXOIC);
+        /* Don't stop capture stream for external clock sync mode */
+    }
 
-	ret = rockchip_i2s_tdm_mclk_reparent(i2s_tdm);
-	if (ret)
-		return ret;
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
-			   I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
-			   I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
-			   I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
-			   I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
-
-	dev_info(i2s_tdm->dev, "CLK-ALWAYS-ON: mclk: %d, bclk: %d, fsync: %d\n",
-		 mclk_rate, bclk_rate, DEFAULT_FS);
-
-	return 0;
+    return IRQ_HANDLED;
 }
 
-static int rockchip_i2s_tdm_register_platform(struct device *dev)
+static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	struct snd_soc_component *comp;
-	int ret = 0;
-
-	if (device_property_read_bool(dev, "rockchip,no-dmaengine")) {
-		i2s_tdm->no_pcm = true;
-		dev_info(dev, "Used for Multi-DAI\n");
-		return 0;
-	}
-
-	if (device_property_read_bool(dev, "rockchip,digital-loopback")) {
-		ret = devm_snd_dmaengine_dlp_register(dev, &dconfig);
-		if (ret)
-			dev_err(dev, "Could not register DLP\n");
-		return ret;
-	}
+    struct device_node *node = pdev->dev.of_node;
+    const struct of_device_id *of_id;
+    struct rk_i2s_tdm_dev *i2s_tdm;
+    struct snd_soc_dai_driver *soc_dai;
+    struct resource *res;
+    void __iomem *regs;
+#ifdef HAVE_SYNC_RESET
+    bool sync;
+#endif
+    int ret, val, i, irq;
 
-	if (i2s_tdm->clk_trcm) {
-		ret =  devm_snd_dmaengine_trcm_register(dev);
-		if (ret) {
-			dev_err(dev, "Could not register TRCM PCM\n");
-			return ret;
-		}
+    ret = rockchip_i2s_tdm_dai_prepare(pdev, &soc_dai);
+    if (ret)
+    return ret;
+
+    i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
+    if (!i2s_tdm)
+    return -ENOMEM;
+
+    i2s_tdm->dev = &pdev->dev;
+    i2s_tdm->volume = 100;
+    /* Initial mute state = true (muted on boot) */
+    i2s_tdm->mute = true; 
+    
+    /* Initialize ALSA control pointers */
+    i2s_tdm->mute_kcontrol = NULL;
+    i2s_tdm->dai = NULL;
+    
+    /* Initialize MCLK multiplier - 512 by default */
+    i2s_tdm->mclk_multiplier = 512;
+    
+    /* Initialize automatic mute - default ON (no signal yet) */
+    i2s_tdm->auto_mute_active = true;
+    i2s_tdm->user_mute_priority = false;
+    mutex_init(&i2s_tdm->mute_lock);
+    INIT_DELAYED_WORK(&i2s_tdm->mute_post_work, rockchip_i2s_tdm_mute_post_work);
+    
+    /* Initialize pause state */
+    i2s_tdm->playback_paused = false;
+    i2s_tdm->capture_paused = false;
+    
+    /* Initialize configurable postmute delay */
+    i2s_tdm->postmute_delay_ms = DEFAULT_POSTMUTE_DELAY_MS;    // default for mute hold
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Initial volume = %d, mute = %d (sound %s)\n", 
+     i2s_tdm->volume, i2s_tdm->mute, i2s_tdm->mute ? "OFF" : "ON");
+
+    i2s_tdm->mute_gpio = devm_gpiod_get_optional(&pdev->dev, "mute", GPIOD_OUT_HIGH);
+    if (IS_ERR(i2s_tdm->mute_gpio)) {
+    ret = PTR_ERR(i2s_tdm->mute_gpio);
+    dev_err(&pdev->dev, "Failed to get mute GPIO: %d\n", ret);
+    i2s_tdm->mute_gpio = NULL;
+    } else if (i2s_tdm->mute_gpio) {
+    /* Set GPIO: mute=true -> GPIO=1 (muted) */
+    gpiod_set_value(i2s_tdm->mute_gpio, i2s_tdm->mute ? 1 : 0);
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: GPIO mute initialized to %d (sound %s)\n", 
+         i2s_tdm->mute ? 1 : 0, i2s_tdm->mute ? "OFF" : "ON");
+    }
+
+    /* Initialize inverted mute GPIO (GPIO2_A5, pin 69) - LOW when muted */
+    i2s_tdm->mute_inv_gpio = devm_gpiod_get_optional(&pdev->dev, "mute-inv", GPIOD_OUT_LOW);
+    if (IS_ERR(i2s_tdm->mute_inv_gpio)) {
+        ret = PTR_ERR(i2s_tdm->mute_inv_gpio);
+        dev_err(&pdev->dev, "Failed to get inverted mute GPIO: %d\n", ret);
+        i2s_tdm->mute_inv_gpio = NULL;
+    } else if (i2s_tdm->mute_inv_gpio) {
+        gpiod_set_value(i2s_tdm->mute_inv_gpio, i2s_tdm->mute ? 0 : 1);
+        dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Inverted mute GPIO initialized to %d\n", 
+             i2s_tdm->mute ? 0 : 1);
+    }
+
+    /* Initialize DSD-on GPIO */
+    i2s_tdm->dsd_on_gpio = devm_gpiod_get_optional(&pdev->dev, "dsd-enable", GPIOD_OUT_LOW);
+    if (IS_ERR(i2s_tdm->dsd_on_gpio)) {
+    ret = PTR_ERR(i2s_tdm->dsd_on_gpio);
+    dev_err(&pdev->dev, "Failed to get DSD-on GPIO: %d\n", ret);
+    i2s_tdm->dsd_on_gpio = NULL;
+    } else if (i2s_tdm->dsd_on_gpio) {
+    /* Initial state: DSD mode disabled */
+    i2s_tdm->dsd_mode_active = false;
+    gpiod_set_value(i2s_tdm->dsd_on_gpio, 0);
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: DSD-on GPIO initialized to 0 (DSD mode OFF)\n");
+    }
+    
+    /* Initialize DSD sample swap to eliminate purple noise */
+    i2s_tdm->dsd_sample_swap = true;  /* Enabled by default */
+    
+    /* Initialize Channel swap controls */
+    i2s_tdm->pcm_channel_swap = false;   /* PCM channel swap disabled by default */
+    i2s_tdm->dsd_physical_swap = false;  /* DSD physical swap disabled by default */
+
+    /* Initialize frequency domain GPIO (GPIO1_D1) polarity control */
+    i2s_tdm->freq_domain_invert = false;  /* Default: no inversion */
+    i2s_tdm->freq_domain_gpio = devm_gpiod_get_optional(&pdev->dev, "freq-domain", GPIOD_ASIS);
+    if (IS_ERR(i2s_tdm->freq_domain_gpio)) {
+        /* GPIO might be controlled by gpio-mux-clock, this is normal */
+        i2s_tdm->freq_domain_gpio = NULL;
+        dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Frequency domain GPIO controlled by gpio-mux-clock\n");
+    } else if (i2s_tdm->freq_domain_gpio) {
+        dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Frequency domain GPIO available for polarity control\n");
+    }
+
+    of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
+    if (!of_id)
+    return -EINVAL;
+
+    spin_lock_init(&i2s_tdm->lock);
+    i2s_tdm->soc_data = (const struct rk_i2s_soc_data *)of_id->data;
+
+    for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
+    if (of_property_read_bool(node, of_quirks[i].quirk))
+        i2s_tdm->quirks |= of_quirks[i].id;
+
+    i2s_tdm->bclk_fs = 64;
+    if (!of_property_read_u32(node, "rockchip,bclk-fs", &val)) {
+    if ((val >= 32) && (val % 2 == 0))
+        i2s_tdm->bclk_fs = val;
+    }
+
+    i2s_tdm->clk_trcm = I2S_CKR_TRCM_TXRX;
+    if (!of_property_read_u32(node, "rockchip,clk-trcm", &val)) {
+    if (val >= 0 && val <= 2) {
+        i2s_tdm->clk_trcm = val << I2S_CKR_TRCM_SHIFT;
+        if (i2s_tdm->clk_trcm)
+    soc_dai->symmetric_rate = 1;
+    }
+    }
+
+    i2s_tdm->tdm_fsync_half_frame =
+    of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
+
+    if (of_property_read_bool(node, "rockchip,playback-only"))
+    soc_dai->capture.channels_min = 0;
+    else if (of_property_read_bool(node, "rockchip,capture-only"))
+    soc_dai->playback.channels_min = 0;
 
-		comp = snd_soc_lookup_component(i2s_tdm->dev,
-						SND_DMAENGINE_TRCM_DRV_NAME);
-		if (!comp) {
-			dev_err(dev, "Could not find TRCM PCM\n");
-			ret = -ENODEV;
-		}
+    i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
 
-		i2s_tdm->pcm_comp = comp;
+#ifdef HAVE_SYNC_RESET
+    sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
+           of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
+
+    if (i2s_tdm->clk_trcm && sync) {
+    struct device_node *cru_node;
+
+    cru_node = of_parse_phandle(node, "rockchip,cru", 0);
+    i2s_tdm->cru_base = of_iomap(cru_node, 0);
+    if (!i2s_tdm->cru_base)
+        return -ENOENT;
+
+    i2s_tdm->tx_reset_id = of_i2s_resetid_get(node, "tx-m");
+    i2s_tdm->rx_reset_id = of_i2s_resetid_get(node, "rx-m");
+    }
+#endif
+
+    i2s_tdm->tx_reset = devm_reset_control_get(&pdev->dev, "tx-m");
+    if (IS_ERR(i2s_tdm->tx_reset)) {
+    ret = PTR_ERR(i2s_tdm->tx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->rx_reset = devm_reset_control_get(&pdev->dev, "rx-m");
+    if (IS_ERR(i2s_tdm->rx_reset)) {
+    ret = PTR_ERR(i2s_tdm->rx_reset);
+    if (ret != -ENOENT)
+        return ret;
+    }
+
+    i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
+    if (IS_ERR(i2s_tdm->hclk))
+    return PTR_ERR(i2s_tdm->hclk);
+
+    ret = clk_prepare_enable(i2s_tdm->hclk);
+    if (ret)
+    return ret;
+
+    i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
+    if (IS_ERR(i2s_tdm->mclk_tx))
+    return PTR_ERR(i2s_tdm->mclk_tx);
+
+    i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
+    if (IS_ERR(i2s_tdm->mclk_rx))
+    return PTR_ERR(i2s_tdm->mclk_rx);
+
+  i2s_tdm->mclk_external = 0;
+    i2s_tdm->mclk_external =
+        of_property_read_bool(node, "my,mclk_external");
+    if (i2s_tdm->mclk_external) {
+        dev_dbg(&pdev->dev, "External MCLK mode detected\n");
+        i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
+        if (IS_ERR(i2s_tdm->mclk_ext)) {
+            return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
+                 "Failed to get clock mclk_ext\n");
+        }
+        dev_info(&pdev->dev, "mclk_ext clock loaded successfully\n");
+
+        i2s_tdm->mclk_ext_mux = 0;
+        i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
+        if (!IS_ERR(i2s_tdm->clk_44)) {
+            dev_info(&pdev->dev, "clk_44 loaded successfully\n");
+            i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
+            if (!IS_ERR(i2s_tdm->clk_48)) {
+                i2s_tdm->mclk_ext_mux = 1;
+                dev_info(&pdev->dev, "clk_48 loaded successfully - external clock switching enabled\n");
+            } else {
+                dev_warn(&pdev->dev, "Failed to get clk_48: %ld\n", PTR_ERR(i2s_tdm->clk_48));
+            }
+        } else {
+            dev_warn(&pdev->dev, "Failed to get clk_44: %ld\n", PTR_ERR(i2s_tdm->clk_44));
+        }
+    }
+
+    i2s_tdm->io_multiplex =
+        of_property_read_bool(node, "rockchip,io-multiplex");
+
+    i2s_tdm->mclk_calibrate =
+    of_property_read_bool(node, "rockchip,mclk-calibrate");
+
+    if (i2s_tdm->mclk_calibrate) {
+    i2s_tdm->mclk_tx_src = devm_clk_get(&pdev->dev, "mclk_tx_src");
+    if (IS_ERR(i2s_tdm->mclk_tx_src))
+        return PTR_ERR(i2s_tdm->mclk_tx_src);
+
+    i2s_tdm->mclk_rx_src = devm_clk_get(&pdev->dev, "mclk_rx_src");
+    if (IS_ERR(i2s_tdm->mclk_rx_src))
+        return PTR_ERR(i2s_tdm->mclk_rx_src);
+
+    i2s_tdm->mclk_root0 = devm_clk_get(&pdev->dev, "mclk_root0");
+    if (IS_ERR(i2s_tdm->mclk_root0))
+        return PTR_ERR(i2s_tdm->mclk_root0);
+
+    i2s_tdm->mclk_root1 = devm_clk_get(&pdev->dev, "mclk_root1");
+    if (IS_ERR(i2s_tdm->mclk_root1))
+        return PTR_ERR(i2s_tdm->mclk_root1);
+
+    i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
+    i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
+    i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
+    i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
+    }
+
+    regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+    if (IS_ERR(regs))
+    return PTR_ERR(regs);
+
+    i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+        &rockchip_i2s_tdm_regmap_config);
+    if (IS_ERR(i2s_tdm->regmap))
+    return PTR_ERR(i2s_tdm->regmap);
+
+    irq = platform_get_irq_optional(pdev, 0);
+    if (irq > 0) {
+    ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
+           IRQF_SHARED, node->name, i2s_tdm);
+    if (ret) {
+        dev_err(&pdev->dev, "failed to request irq %u\n", irq);
+        return ret;
+    }
+    }
+
+    i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
+    i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
+    i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
+
+    ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
+    return ret;
+    }
+    
+    /* After TX routing initialization apply DSD physical swap settings if needed */
+    rockchip_i2s_tdm_apply_dsd_physical_swap(i2s_tdm);
+
+    ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
+    if (ret < 0) {
+    dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
+    return ret;
+    }
+
+    atomic_set(&i2s_tdm->refcount, 0);
+    dev_set_drvdata(&pdev->dev, i2s_tdm);
+    pm_runtime_enable(&pdev->dev);
+    
+    dev_info(&pdev->dev, "ROCKCHIP_I2S_TDM: Pause/Resume support enabled\n");
+
+    if (!pm_runtime_enabled(&pdev->dev)) {
+    ret = i2s_tdm_runtime_resume(&pdev->dev);
+    if (ret)
+        goto err_pm_disable;
+    }
+
+    if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
+    unsigned int rate = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_bclk = DEFAULT_FS * DEFAULT_MCLK_FS;
+    unsigned int div_lrck = i2s_tdm->bclk_fs;
+
+    div_bclk = DIV_ROUND_CLOSEST(rate, div_lrck * DEFAULT_FS);
+
+    /* assign generic freq */
+    clk_set_rate(i2s_tdm->mclk_rx, rate);
+    clk_set_rate(i2s_tdm->mclk_tx, rate);
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
+       I2S_CLKDIV_RXM_MASK | I2S_CLKDIV_TXM_MASK,
+       I2S_CLKDIV_RXM(div_bclk) | I2S_CLKDIV_TXM(div_bclk));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+       I2S_CKR_RSD_MASK | I2S_CKR_TSD_MASK,
+       I2S_CKR_RSD(div_lrck) | I2S_CKR_TSD(div_lrck));
+
+    if (i2s_tdm->clk_trcm)
+        rockchip_i2s_tdm_xfer_trcm_start(i2s_tdm);
+    else
+        rockchip_i2s_tdm_xfer_start(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+
+    pm_runtime_forbid(&pdev->dev);
+    }
+    
+    /* Enable continuous MCLK if corresponding quirk is set */
+    if (i2s_tdm->quirks & QUIRK_MCLK_ALWAYS_ON) {
+        dev_info(&pdev->dev, "MCLK always-on mode enabled\n");
+        /* Make sure MCLK is enabled and will remain enabled */
+        ret = clk_prepare_enable(i2s_tdm->mclk_tx);
+        if (ret) {
+            dev_err(&pdev->dev, "Failed to enable mclk_tx for always-on: %d\n", ret);
+            goto err_pm_disable;
+        }
+        ret = clk_prepare_enable(i2s_tdm->mclk_rx);
+        if (ret) {
+            dev_err(&pdev->dev, "Failed to enable mclk_rx for always-on: %d\n", ret);
+            clk_disable_unprepare(i2s_tdm->mclk_tx);
+            goto err_pm_disable;
+        }
+    }
+
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
+           I2S_DMACR_TDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
+           I2S_DMACR_RDL(16));
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_TRCM_MASK, i2s_tdm->clk_trcm);
+
+    /* Initialize MSS bit to MASTER mode (generate clocks) by default */
+    regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
+           I2S_CKR_MSS_MASK, I2S_CKR_MSS_MASTER);
+    i2s_tdm->is_master_mode = true;
+    dev_info(&pdev->dev, "I2S initialized in MASTER mode (will generate BCLK/LRCK)\n");
+
+    /* Apply default pinctrl state to enable I2S pins */
+    ret = pinctrl_pm_select_default_state(&pdev->dev);
+    if (ret) {
+        dev_warn(&pdev->dev, "Failed to set default pinctrl state: %d\n", ret);
+    } else {
+        dev_info(&pdev->dev, "Applied default pinctrl state (I2S pins enabled)\n");
+    }
+
+    if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
+    i2s_tdm->soc_data->init(&pdev->dev, res->start);
+
+    ret = devm_snd_soc_register_component(&pdev->dev,
+              &rockchip_i2s_tdm_component_with_copy,
+              soc_dai, 1);
+
+    if (ret) {
+    dev_warn(&pdev->dev, "Failed to register component with copy support: %d\n", ret);
+    dev_info(&pdev->dev, "Falling back to standard component (no volume processing)\n");
+    
+    /* Fallback to standard component */
+    ret = devm_snd_soc_register_component(&pdev->dev,
+                  &rockchip_i2s_tdm_component,
+                  soc_dai, 1);
+    if (ret) {
+        dev_err(&pdev->dev, "Could not register DAI\n");
+        goto err_suspend;
+    }
+    } else {
+    dev_info(&pdev->dev, "Audiophile component registered successfully with copy callbacks\n");
+    }
+
+    if (of_property_read_bool(node, "rockchip,no-dmaengine"))
+    return ret;
+
+    if (of_property_read_bool(node, "rockchip,digital-loopback"))
+    ret = devm_snd_dmaengine_dlp_register(&pdev->dev, &dconfig);
+    else
+    /* Use custom configuration with pause/resume support */
+    ret = devm_snd_dmaengine_pcm_register(&pdev->dev, 
+             &rockchip_i2s_tdm_dmaengine_pcm_config, 
+             0);
+    if (ret) {
+    dev_err(&pdev->dev, "Could not register PCM\n");
+    return ret;
+    }
+
+    /* Create sysfs attribute for MCLK multiplier switching */
+    ret = device_create_file(&pdev->dev, &dev_attr_mclk_multiplier);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create mclk_multiplier sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+
+    
+    /* Create sysfs attribute for DSD sample swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_dsd_sample_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create dsd_sample_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for PCM channel swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_pcm_channel_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create pcm_channel_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for DSD physical swap */
+    ret = device_create_file(&pdev->dev, &dev_attr_dsd_physical_swap);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create dsd_physical_swap sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for frequency domain GPIO polarity control */
+    ret = device_create_file(&pdev->dev, &dev_attr_freq_domain_invert);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create freq_domain_invert sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for manual DSD mode control */
+    ret = device_create_file(&pdev->dev, &dev_attr_dsd_mode_manual);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create dsd_mode_manual sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for postmute delay */
+    ret = device_create_file(&pdev->dev, &dev_attr_postmute_delay_ms);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create postmute_delay_ms sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
+    
+    /* Create sysfs attribute for mute control */
+    ret = device_create_file(&pdev->dev, &dev_attr_mute);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to create mute sysfs attribute: %d\n", ret);
+        /* Not critical, continue */
+    }
 
-		return ret;
-	}
+    return 0;
 
-	ret = devm_snd_dmaengine_pcm_register(dev, NULL, 0);
-	if (ret)
-		dev_err(dev, "Could not register PCM\n");
+err_suspend:
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
+err_pm_disable:
+    pm_runtime_disable(&pdev->dev);
 
-	return ret;
+    return ret;
 }
 
-static int __maybe_unused i2s_tdm_runtime_suspend(struct device *dev)
+static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-
-	if (i2s_tdm->pcm_comp && i2s_tdm->clk_trcm) {
-		rockchip_i2s_tdm_dma_ctrl(i2s_tdm, 0, 0);
-		rockchip_i2s_tdm_dma_ctrl(i2s_tdm, 1, 0);
-		rockchip_trcm_dma_guard_ctrl(i2s_tdm, 0, 0);
-		rockchip_trcm_dma_guard_ctrl(i2s_tdm, 1, 0);
-	}
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	regcache_cache_only(i2s_tdm->regmap, true);
-	i2s_tdm_disable_unprepare_mclk(i2s_tdm);
+    /* Cleanup auto-mute timer */
+    cancel_delayed_work_sync(&i2s_tdm->mute_post_work);
 
-	clk_disable_unprepare(i2s_tdm->hclk);
+    /* Remove sysfs attributes */
+    device_remove_file(&pdev->dev, &dev_attr_mclk_multiplier);
+    device_remove_file(&pdev->dev, &dev_attr_dsd_sample_swap);
+    device_remove_file(&pdev->dev, &dev_attr_pcm_channel_swap);
+    device_remove_file(&pdev->dev, &dev_attr_dsd_physical_swap);
+    device_remove_file(&pdev->dev, &dev_attr_freq_domain_invert);
+
+    pm_runtime_disable(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+    i2s_tdm_runtime_suspend(&pdev->dev);
+
+    /* Turn off MCLK regardless of quirk when removing driver */
+    clk_disable_unprepare(i2s_tdm->mclk_tx);
+    clk_disable_unprepare(i2s_tdm->mclk_rx);
+    clk_disable_unprepare(i2s_tdm->hclk);
 
-	pinctrl_pm_select_idle_state(dev);
-
-	return 0;
+    return 0;
 }
 
-static int rockchip_i2s_tdm_pinctrl_select_clk_state(struct device *dev)
+static void rockchip_i2s_tdm_platform_shutdown(struct platform_device *pdev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-
-	if (IS_ERR_OR_NULL(i2s_tdm->pinctrl) || !i2s_tdm->clk_state)
-		return 0;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
 
-	pinctrl_select_state(i2s_tdm->pinctrl, i2s_tdm->clk_state);
-
-	return 0;
+    pm_runtime_get_sync(i2s_tdm->dev);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
+    rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
+    pm_runtime_put(i2s_tdm->dev);
 }
 
-static int __maybe_unused i2s_tdm_runtime_resume(struct device *dev)
+#ifdef CONFIG_PM_SLEEP
+static int rockchip_i2s_tdm_suspend(struct device *dev)
 {
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
-	int ret;
-
-	/*
-	 * pinctrl default state is invoked by ASoC framework, so,
-	 * we just handle clk state here if DT assigned.
-	 */
-	if (i2s_tdm->is_master_mode)
-		rockchip_i2s_tdm_pinctrl_select_clk_state(dev);
-
-	ret = clk_prepare_enable(i2s_tdm->hclk);
-	if (ret)
-		goto err_hclk;
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 
-	ret = i2s_tdm_prepare_enable_mclk(i2s_tdm);
-	if (ret)
-		goto err_mclk;
+    regcache_mark_dirty(i2s_tdm->regmap);
 
-	regcache_cache_only(i2s_tdm->regmap, false);
-	regcache_mark_dirty(i2s_tdm->regmap);
-
-	/*
-	 * XFER must be placed after all registers sync done,
-	 * because a lots of registers depends on the XFER-Disabled.
-	 */
-	ret = 0;
-	ret |= regcache_sync_region(i2s_tdm->regmap, I2S_TXCR, I2S_INTCR);
-	ret |= regcache_sync_region(i2s_tdm->regmap, I2S_TXDR, I2S_CLKDIV);
-	ret |= regcache_sync_region(i2s_tdm->regmap, I2S_XFER, I2S_XFER);
-	if (ret) {
-		dev_err(i2s_tdm->dev, "Failed to sync registers\n");
-		goto err_regcache;
-	}
-
-	/*
-	 * should be placed after regcache sync done to back
-	 * to the slave mode and then enable clk state.
-	 */
-	if (!i2s_tdm->is_master_mode)
-		rockchip_i2s_tdm_pinctrl_select_clk_state(dev);
-
-	return 0;
-
-err_regcache:
-	i2s_tdm_disable_unprepare_mclk(i2s_tdm);
-err_mclk:
-	clk_disable_unprepare(i2s_tdm->hclk);
-err_hclk:
-	return ret;
-}
-
-static void __maybe_unused rockchip_i2s_tdm_unmap(struct rk_i2s_tdm_dev *i2s_tdm)
-{
-#ifdef HAVE_SYNC_RESET
-	if (i2s_tdm->cru_base)
-		iounmap(i2s_tdm->cru_base);
-#endif
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (i2s_tdm->clk_src_base)
-		iounmap(i2s_tdm->clk_src_base);
-#endif
+    return 0;
 }
 
-static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
+static int rockchip_i2s_tdm_resume(struct device *dev)
 {
-	struct device_node *node = pdev->dev.of_node;
-	const struct of_device_id *of_id;
-	struct rk_i2s_tdm_dev *i2s_tdm;
-	struct resource *res;
-	void __iomem *regs;
-#ifdef HAVE_SYNC_RESET
-	bool sync;
-#endif
-	int ret, val, i, irq;
-
-	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
-	if (!i2s_tdm)
-		return -ENOMEM;
-
-	i2s_tdm->dev = &pdev->dev;
-	i2s_tdm->lrck_ratio = 1;
-
-	if (!device_property_read_u32(i2s_tdm->dev, "rockchip,resume-deferred-ms", &val))
-		i2s_tdm->resume_deferred_ms = val;
-
-	/*
-	 * Should use flag GPIOD_ASIS not to reclaim LRCK pin as GPIO function,
-	 * because we use the same PIN and just read EXT_PORT value which show
-	 * the pin status.
-	 */
-	i2s_tdm->i2s_lrck_gpio = devm_gpiod_get_optional(i2s_tdm->dev, "i2s-lrck",
-							 GPIOD_ASIS);
-	if (IS_ERR(i2s_tdm->i2s_lrck_gpio)) {
-		ret = PTR_ERR(i2s_tdm->i2s_lrck_gpio);
-		dev_err(i2s_tdm->dev, "Failed to get i2s_lrck_gpio %d\n", ret);
-		return ret;
-	}
-
-	of_id = of_match_device(rockchip_i2s_tdm_match, &pdev->dev);
-	if (!of_id)
-		return -EINVAL;
-
-	spin_lock_init(&i2s_tdm->lock);
-	i2s_tdm->soc_data = (struct rk_i2s_soc_data *)of_id->data;
-
-	for (i = 0; i < ARRAY_SIZE(of_quirks); i++)
-		if (of_property_read_bool(node, of_quirks[i].quirk))
-			i2s_tdm->quirks |= of_quirks[i].id;
-
-	i2s_tdm->frame_width = 64;
-
-	i2s_tdm->clk_trcm = TRCM_TXRX;
-	if (of_property_read_bool(node, "rockchip,trcm-sync-tx-only"))
-		i2s_tdm->clk_trcm = TRCM_TX;
-	if (of_property_read_bool(node, "rockchip,trcm-sync-rx-only")) {
-		if (i2s_tdm->clk_trcm) {
-			dev_err(i2s_tdm->dev, "invalid trcm-sync configuration\n");
-			return -EINVAL;
-		}
-		i2s_tdm->clk_trcm = TRCM_RX;
-	}
-
-	rockchip_i2s_tdm_wait_time_init(i2s_tdm);
-
-	ret = rockchip_i2s_tdm_init_dai(i2s_tdm);
-	if (ret)
-		return ret;
-
-	i2s_tdm->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
-
-	i2s_tdm->tx_reset = devm_reset_control_get_optional_exclusive(&pdev->dev,
-								      "tx-m");
-	if (IS_ERR(i2s_tdm->tx_reset)) {
-		ret = PTR_ERR(i2s_tdm->tx_reset);
-		return dev_err_probe(i2s_tdm->dev, ret,
-				     "Error in tx-m reset control\n");
-	}
-
-	i2s_tdm->rx_reset = devm_reset_control_get_optional_exclusive(&pdev->dev,
-								      "rx-m");
-	if (IS_ERR(i2s_tdm->rx_reset)) {
-		ret = PTR_ERR(i2s_tdm->rx_reset);
-		return dev_err_probe(i2s_tdm->dev, ret,
-				     "Error in rx-m reset control\n");
-	}
-
-	i2s_tdm->hclk = devm_clk_get(&pdev->dev, "hclk");
-	if (IS_ERR(i2s_tdm->hclk)) {
-		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->hclk),
-				     "Failed to get clock hclk\n");
-	}
-
-	i2s_tdm->mclk_tx = devm_clk_get(&pdev->dev, "mclk_tx");
-	if (IS_ERR(i2s_tdm->mclk_tx)) {
-		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_tx),
-				     "Failed to get clock mclk_tx\n");
-	}
-
-	i2s_tdm->mclk_rx = devm_clk_get(&pdev->dev, "mclk_rx");
-	if (IS_ERR(i2s_tdm->mclk_rx)) {
-		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_rx),
-				     "Failed to get clock mclk_rx\n");
-	}
-
-	i2s_tdm->tdm_fsync_half_frame =
-		of_property_read_bool(node, "rockchip,tdm-fsync-half-frame");
-
-	i2s_tdm->pinctrl = devm_pinctrl_get(&pdev->dev);
-	if (!IS_ERR_OR_NULL(i2s_tdm->pinctrl)) {
-		i2s_tdm->clk_state = pinctrl_lookup_state(i2s_tdm->pinctrl, "clk");
-		if (IS_ERR(i2s_tdm->clk_state)) {
-			i2s_tdm->clk_state = NULL;
-			dev_dbg(i2s_tdm->dev, "Have no clk pinctrl state\n");
-		}
-	}
-
-	i2s_tdm->io_multiplex =
-		of_property_read_bool(node, "rockchip,io-multiplex");
-
-	ret = rockchip_i2s_tdm_get_calibrate_mclks(i2s_tdm);
-	if (ret)
-		return dev_err_probe(i2s_tdm->dev, ret,
-				     "mclk-calibrate clocks missing");
-
-	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
-	if (IS_ERR(regs)) {
-		return dev_err_probe(i2s_tdm->dev, PTR_ERR(regs),
-				     "Failed to get resource IORESOURCE_MEM\n");
-	}
-
-	i2s_tdm->regmap = devm_regmap_init_mmio(&pdev->dev, regs,
-						&rockchip_i2s_tdm_regmap_config);
-	if (IS_ERR(i2s_tdm->regmap)) {
-		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->regmap),
-				     "Failed to initialise regmap\n");
-	}
-
-	if (i2s_tdm->has_playback) {
-		i2s_tdm->playback_dma_data.addr = res->start + I2S_TXDR;
-		i2s_tdm->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		i2s_tdm->playback_dma_data.maxburst = MAXBURST_PER_FIFO;
-	}
-
-	if (i2s_tdm->has_capture) {
-		i2s_tdm->capture_dma_data.addr = res->start + I2S_RXDR;
-		i2s_tdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-		i2s_tdm->capture_dma_data.maxburst = MAXBURST_PER_FIFO;
-	}
-
-	irq = platform_get_irq_optional(pdev, 0);
-	if (irq > 0) {
-		ret = devm_request_irq(&pdev->dev, irq, rockchip_i2s_tdm_isr,
-				       IRQF_SHARED, node->name, i2s_tdm);
-		if (ret) {
-			dev_err(&pdev->dev, "failed to request irq %u\n", irq);
-			return ret;
-		}
-	}
-
-	ret = clk_prepare_enable(i2s_tdm->hclk);
-	if (ret) {
-		return dev_err_probe(i2s_tdm->dev, ret,
-				     "Failed to enable clock hclk\n");
-	}
-
-	ret = rockchip_i2s_tdm_tx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S TX path prepare failed: %d\n", ret);
-		goto err_disable_hclk;
-	}
-
-	ret = rockchip_i2s_tdm_rx_path_prepare(i2s_tdm, node);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "I2S RX path prepare failed: %d\n", ret);
-		goto err_disable_hclk;
-	}
-
-	dev_set_drvdata(&pdev->dev, i2s_tdm);
-
-	if (i2s_tdm->mclk_calibrate) {
-		i2s_tdm->mclk_root0_initial_freq = clk_get_rate(i2s_tdm->mclk_root0);
-		i2s_tdm->mclk_root1_initial_freq = clk_get_rate(i2s_tdm->mclk_root1);
-		i2s_tdm->mclk_root0_freq = i2s_tdm->mclk_root0_initial_freq;
-		i2s_tdm->mclk_root1_freq = i2s_tdm->mclk_root1_initial_freq;
-	}
-
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_TDL_MASK,
-			   I2S_DMACR_TDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_DMACR, I2S_DMACR_RDL_MASK,
-			   I2S_DMACR_RDL(16));
-	regmap_update_bits(i2s_tdm->regmap, I2S_CKR, I2S_CKR_TRCM_MASK,
-			   i2s_tdm->clk_trcm << I2S_CKR_TRCM_SHIFT);
-
-	if (i2s_tdm->soc_data && i2s_tdm->soc_data->init)
-		i2s_tdm->soc_data->init(&pdev->dev, res->start);
-
-	/*
-	 * CLK_ALWAYS_ON should be placed after all registers write done,
-	 * because this situation will enable XFER bit which will make
-	 * some registers(depend on XFER) write failed.
-	 */
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON) {
-		ret = rockchip_i2s_tdm_keep_clk_always_on(i2s_tdm);
-		if (ret)
-			goto err_disable_hclk;
-	}
-
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	ret = rockchip_i2s_tdm_multi_lanes_parse(i2s_tdm);
-	if (ret)
-		goto err_unmap;
-#endif
-
-#ifdef HAVE_SYNC_RESET
-	sync = of_device_is_compatible(node, "rockchip,px30-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk1808-i2s-tdm") ||
-	       of_device_is_compatible(node, "rockchip,rk3308-i2s-tdm");
-
-	if (i2s_tdm->clk_trcm && sync) {
-		struct device_node *cru_node;
-
-		cru_node = of_parse_phandle(node, "rockchip,cru", 0);
-		i2s_tdm->cru_base = of_iomap(cru_node, 0);
-		if (!i2s_tdm->cru_base) {
-			ret = -ENOENT;
-			goto err_unmap;
-		}
+    struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+    int ret;
 
-		i2s_tdm->id = (res->start >> 16) & GENMASK(3, 0);
-	}
-#endif
-
-	/*
-	 * MUST: after pm_runtime_enable step, any register R/W
-	 * should be wrapped with pm_runtime_get_sync/put.
-	 *
-	 * Another approach is to enable the regcache true to
-	 * avoid access HW registers.
-	 *
-	 * Alternatively, performing the registers R/W before
-	 * pm_runtime_enable is also a good option.
-	 */
-	pm_runtime_enable(&pdev->dev);
-
-	/*
-	 * Should be placed after pm_runtime_enable to do
-	 * rpm_resume at the moment. otherwise, it will make sense
-	 * at the next pm_runtime_get.
-	 */
-	if (i2s_tdm->quirks & QUIRK_ALWAYS_ON)
-		pm_runtime_forbid(i2s_tdm->dev);
-
-	ret = rockchip_i2s_tdm_register_platform(&pdev->dev);
-	if (ret)
-		goto err_suspend;
-
-	ret = devm_snd_soc_register_component(&pdev->dev,
-					      &rockchip_i2s_tdm_component,
-					      i2s_tdm->dai, 1);
-
-	if (ret) {
-		dev_err(&pdev->dev, "Could not register DAI\n");
-		goto err_suspend;
-	}
-
-	return 0;
+    ret = pm_runtime_get_sync(dev);
+    if (ret < 0)
+    return ret;
 
-err_suspend:
-#ifdef CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES
-	if (i2s_tdm->clk_src_base)
-		iounmap(i2s_tdm->clk_src_base);
-#endif
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
-
-#if defined(HAVE_SYNC_RESET) || defined(CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES)
-err_unmap:
-	rockchip_i2s_tdm_unmap(i2s_tdm);
-#endif
+    ret = regcache_sync(i2s_tdm->regmap);
 
-err_disable_hclk:
-	clk_disable_unprepare(i2s_tdm->hclk);
+    pm_runtime_put(dev);
 
-	return ret;
+    return ret;
 }
-
-static int rockchip_i2s_tdm_remove(struct platform_device *pdev)
-{
-#if defined(HAVE_SYNC_RESET) || defined(CONFIG_SND_SOC_ROCKCHIP_I2S_TDM_MULTI_LANES)
-	rockchip_i2s_tdm_unmap(dev_get_drvdata(&pdev->dev));
 #endif
-	if (!pm_runtime_status_suspended(&pdev->dev))
-		i2s_tdm_runtime_suspend(&pdev->dev);
-
-	pm_runtime_disable(&pdev->dev);
-
-	return 0;
-}
-
-static void rockchip_i2s_tdm_platform_shutdown(struct platform_device *pdev)
-{
-	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(&pdev->dev);
-
-	pm_runtime_get_sync(i2s_tdm->dev);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_PLAYBACK);
-	rockchip_i2s_tdm_stop(i2s_tdm, SNDRV_PCM_STREAM_CAPTURE);
-	pm_runtime_put(i2s_tdm->dev);
-}
 
 static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
-	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
-			   NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)
+    SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+           NULL)
+    SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+    rockchip_i2s_tdm_resume)
 };
 
 static struct platform_driver rockchip_i2s_tdm_driver = {
-	.probe = rockchip_i2s_tdm_probe,
-	.remove = rockchip_i2s_tdm_remove,
-	.shutdown = rockchip_i2s_tdm_platform_shutdown,
-	.driver = {
-		.name = DRV_NAME,
-		.of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
-		.pm = &rockchip_i2s_tdm_pm_ops,
-	},
+    .probe = rockchip_i2s_tdm_probe,
+    .remove = rockchip_i2s_tdm_remove,
+    .shutdown = rockchip_i2s_tdm_platform_shutdown,
+    .driver = {
+    .name = DRV_NAME,
+    .of_match_table = of_match_ptr(rockchip_i2s_tdm_match),
+    .pm = &rockchip_i2s_tdm_pm_ops,
+    },
 };
+
 module_platform_driver(rockchip_i2s_tdm_driver);
 
 MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
 MODULE_AUTHOR("Sugar Zhang <sugar.zhang@rock-chips.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:" DRV_NAME);
-MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
+MODULE_DEVICE_TABLE(of, rockchip_i2s_tdm_match);
\ No newline at end of file
